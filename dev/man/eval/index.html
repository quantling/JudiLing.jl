<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Evaluation · JudiLing.jl</title><link rel="canonical" href="https://quantling.github.io/JudiLing.jl/man/eval/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JudiLing.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../input/">Loading data</a></li><li><a class="tocitem" href="../make_cue_matrix/">Make Cue Matrix</a></li><li><a class="tocitem" href="../make_semantic_matrix/">Make Semantic Matrix</a></li><li><a class="tocitem" href="../cholesky/">Cholesky</a></li><li><a class="tocitem" href="../make_adjacency_matrix/">Make Adjacency Matrix</a></li><li><a class="tocitem" href="../make_yt_matrix/">Make Yt Matrix</a></li><li><a class="tocitem" href="../find_path/">Find Paths</a></li><li class="is-active"><a class="tocitem" href>Evaluation</a></li><li><a class="tocitem" href="../output/">Output</a></li><li><a class="tocitem" href="../test_combo/">Test Combo</a></li><li><a class="tocitem" href="../display/">Display</a></li><li><a class="tocitem" href="../utils/">Utils</a></li><li><a class="tocitem" href="../pickle/">Pickle</a></li><li><a class="tocitem" href="../pyndl/">Pyndl</a></li><li><a class="tocitem" href="../wh/">Widrow-Hoff Learning</a></li><li><a class="tocitem" href="../deep_learning/">Deep learning</a></li><li><a class="tocitem" href="../measures_func/">Measures function</a></li></ul></li><li><a class="tocitem" href="../all_manual/">All Manual index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Evaluation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Evaluation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/quantling/JudiLing.jl/blob/master/docs/src/man/eval.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="JudiLing.Comp_Acc_Struct" href="#JudiLing.Comp_Acc_Struct"><code>JudiLing.Comp_Acc_Struct</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A structure that stores information about comprehension accuracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantling/JudiLing.jl/blob/244bb0c648484065ffd5a41781ccc1caf2e5db60/src/eval.jl#LL1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JudiLing.eval_SC" href="#JudiLing.eval_SC"><code>JudiLing.eval_SC</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Assess model accuracy on the basis of the correlations of row vectors of Chat and C or Shat and S. Ideally the target words have highest correlations on the diagonal of the pertinent correlation matrices. Homophones support option is implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantling/JudiLing.jl/blob/244bb0c648484065ffd5a41781ccc1caf2e5db60/src/eval.jl#LL10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JudiLing.eval_SC_loose" href="#JudiLing.eval_SC_loose"><code>JudiLing.eval_SC_loose</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Assess model accuracy on the basis of the correlations of row vectors of Chat and C or Shat and S. Count it as correct if one of the top k candidates is correct. Homophones support option is implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantling/JudiLing.jl/blob/244bb0c648484065ffd5a41781ccc1caf2e5db60/src/eval.jl#LL18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JudiLing.accuracy_comprehension-Tuple{Any, Any, Any}" href="#JudiLing.accuracy_comprehension-Tuple{Any, Any, Any}"><code>JudiLing.accuracy_comprehension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">accuracy_comprehension(S, Shat, data)</code></pre><p>Evaluate comprehension accuracy for training data.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In case of homophones/homographs in the dataset, the correct/incorrect values for base and inflections may be misleading! See below for more information.</p></div></div><p><strong>Obligatory Arguments</strong></p><ul><li><code>S::Matrix</code>: the (gold standard) S matrix</li><li><code>Shat::Matrix</code>: the (predicted) Shat matrix</li><li><code>data::DataFrame</code>: the dataset</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>target_col::Union{String, Symbol}=:Words</code>: the column name for target strings</li><li><code>base::Vector=nothing</code>: base features (typically a lexeme)</li><li><code>inflections::Union{Nothing, Vector}=nothing</code>: other features (typically in inflectional features)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">accuracy_comprehension(
    S_train,
    Shat_train,
    latin_val,
    target_col=:Words,
    base=[:Lexeme],
    inflections=[:Person, :Number, :Tense, :Voice, :Mood]
    )</code></pre><p><strong>Note</strong></p><p>In case of homophones/homographs in the dataset, the correct/incorrect values for base and inflections may be misleading! Consider the following example: The wordform &quot;Äpfel&quot; in German can be nominative plural, genitive plural and accusative plural. Let&#39;s assume we have a dataset in which &quot;Äpfel&quot; occurs in all three case/number combinations (i.e. there are homographs). If all these wordforms have the same semantic vectors (e.g. because they are derived from word2vec or fasttext which typically have a single vector per unique wordform), the predicted semantic vector of the wordform &quot;Äpfel&quot; will be equally correlated with all three case/number combinations in the dataset. In such cases, while the algorithm in this function can unambiguously conclude that the correct surface form &quot;Äpfel&quot; was comprehended, which of the three possible rows is the correct one will be picked somewhat non-deterministically (see https://docs.julialang.org/en/v1/base/collections/#Base.argmax). It is thus possible that the algorithm will then use the genitive plural instead of the intended nominative plural as the ground plural, and will report that &quot;case&quot; was comprehended incorrectly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantling/JudiLing.jl/blob/244bb0c648484065ffd5a41781ccc1caf2e5db60/src/eval.jl#LL25-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JudiLing.accuracy_comprehension-NTuple{5, Any}" href="#JudiLing.accuracy_comprehension-NTuple{5, Any}"><code>JudiLing.accuracy_comprehension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">accuracy_comprehension(
    S_val,
    S_train,
    Shat_val,
    data_val,
    data_train;
    target_col = :Words,
    base = nothing,
    inflections = nothing,
)</code></pre><p>Evaluate comprehension accuracy for validation data.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In case of homophones/homographs in the dataset, the correct/incorrect values for base and inflections may be misleading! See below for more information.</p></div></div><p><strong>Obligatory Arguments</strong></p><ul><li><code>S_val::Matrix</code>: the (gold standard) S matrix of the validation data</li><li><code>S_train::Matrix</code>: the (gold standard) S matrix of the training data</li><li><code>Shat_val::Matrix</code>: the (predicted) Shat matrix of the validation data</li><li><code>data_val::DataFrame</code>: the validation dataset</li><li><code>data_train::DataFrame</code>: the training dataset</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>target_col::Union{String, Symbol}=:Words</code>: the column name for target strings</li><li><code>base::Vector=nothing</code>: base features (typically a lexeme)</li><li><code>inflections::Union{Nothing, Vector}=nothing</code>: other features (typically in inflectional features)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">accuracy_comprehension(
    S_val,
    S_train,
    Shat_val,
    latin_val,
    latin_train,
    target_col=:Words,
    base=[:Lexeme],
    inflections=[:Person, :Number, :Tense, :Voice, :Mood]
    )</code></pre><p><strong>Note</strong></p><p>In case of homophones/homographs in the dataset, the correct/incorrect values for base and inflections may be misleading! Consider the following example: The wordform &quot;Äpfel&quot; in German can be nominative plural, genitive plural and accusative plural. Let&#39;s assume we have a dataset in which &quot;Äpfel&quot; occurs in all three case/number combinations (i.e. there are homographs). If all these wordforms have the same semantic vectors (e.g. because they are derived from word2vec or fasttext which typically have a single vector per unique wordform), the predicted semantic vector of the wordform &quot;Äpfel&quot; will be equally correlated with all three case/number combinations in the dataset. In such cases, while the algorithm in this function can unambiguously conclude that the correct surface form &quot;Äpfel&quot; was comprehended, which of the three possible rows is the correct one will be picked somewhat non-deterministically (see https://docs.julialang.org/en/v1/base/collections/#Base.argmax). It is thus possible that the algorithm will then use the genitive plural instead of the intended nominative plural as the ground plural, and will report that &quot;case&quot; was comprehended incorrectly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantling/JudiLing.jl/blob/244bb0c648484065ffd5a41781ccc1caf2e5db60/src/eval.jl#LL113-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JudiLing.eval_SC-Tuple{AbstractArray, AbstractArray}" href="#JudiLing.eval_SC-Tuple{AbstractArray, AbstractArray}"><code>JudiLing.eval_SC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_SC(SChat::AbstractArray, SC::AbstractArray)</code></pre><p>Assess model accuracy on the basis of the correlations (or Euclidean distances or Cosine Similarities) of row vectors of Chat and C or Shat and S. Ideally the target words have highest correlations (lowest distance/highest similarity) on the diagonal of the pertinent correlation (distance/similarity) matrices.</p><p>If <code>freq</code> is added, token-based accuracy is computed. Token-based accuracy weighs accuracy values according to words&#39; frequency, i.e. if a word has a frequency of 30 and overall there are 3000 tokens (the frequencies of all types sum to 3000), this token&#39;s accuracy will contribute 30/3000.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If there are homophones/homographs in the dataset, this evaluation method may be misleading: the predicted vector will be equally correlated with the target vector of both words and the one on the diagonal will not necessarily be selected as the most correlated. In such cases, supplying the dataset and <code>target_col</code> is recommended which enables taking into account homophones/homographs.</p></div></div><p><strong>Obligatory Arguments</strong></p><ul><li><code>SChat::Union{SparseMatrixCSC, Matrix}</code>: the Chat or Shat matrix</li><li><code>SC::Union{SparseMatrixCSC, Matrix}</code>: the C or S matrix</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>digits</code>: the specified number of digits after the decimal place (or before if negative)</li><li><code>R::Bool=false</code>: if true, pairwise correlation/distance/similarity matrix R is return</li><li><code>freq::Union{Missing, Array{Int64, 1}, Array{Float64,1}}=missing</code>: list of frequencies of the wordforms in X and Y</li><li><code>method::Union{Symbol, String}=:correlation</code>: Method for computing similarities, one of {:correlation, :euclidean, :cosine}.</li></ul><pre><code class="language-julia">eval_SC(Chat_train, cue_obj_train.C)
eval_SC(Chat_val, cue_obj_val.C)
eval_SC(Shat_train, S_train)
eval_SC(Shat_val, S_val)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantling/JudiLing.jl/blob/244bb0c648484065ffd5a41781ccc1caf2e5db60/src/eval.jl#LL229-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JudiLing.eval_SC-Tuple{AbstractArray, AbstractArray, AbstractArray}" href="#JudiLing.eval_SC-Tuple{AbstractArray, AbstractArray, AbstractArray}"><code>JudiLing.eval_SC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_SC(SChat::AbstractArray, SC::AbstractArray, SC_rest::AbstractArray)</code></pre><p>Assess model accuracy on the basis of the correlations (or Euclidean distances or Cosine Similarities) of row vectors of Chat and C or Shat and S. Ideally the target words have highest correlations (lowest distance/highest similarity) on the diagonal of the pertinent correlation (distance/similarity) matrices.</p><p>If <code>freq</code> is added, token-based accuracy is computed. Token-based accuracy weighs accuracy values according to words&#39; frequency, i.e. if a word has a frequency of 30 and overall there are 3000 tokens (the frequencies of all types sum to 3000), this token&#39;s accuracy will contribute 30/3000.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The order is important. The fist gold standard matrix has to be corresponing to the SChat matrix, such as <code>eval_SC(Shat_train, S_train, S_val)</code> or <code>eval_SC(Shat_val, S_val, S_train)</code></p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If there are homophones/homographs in the dataset, this evaluation method may be misleading: the predicted vector will be equally correlated with the target vector of both words and the one on the diagonal will not necessarily be selected as the most correlated. In such cases, supplying the dataset and target_col is recommended which enables taking into account homophones/homographs.</p></div></div><p><strong>Obligatory Arguments</strong></p><ul><li><code>SChat::Union{SparseMatrixCSC, Matrix}</code>: the Chat or Shat matrix</li><li><code>SC::Union{SparseMatrixCSC, Matrix}</code>: the training/validation C or S matrix</li><li><code>SC_rest::Union{SparseMatrixCSC, Matrix}</code>: the validation/training C or S matrix</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>digits</code>: the specified number of digits after the decimal place (or before if negative)</li><li><code>R::Bool=false</code>: if true, pairwise correlation/distance/similarity matrix R is return</li><li><code>freq::Union{Missing, Array{Int64, 1}, Array{Float64,1}}=missing</code>: list of frequencies of the wordforms in X and Y</li><li><code>method::Union{Symbol, String}=:correlation</code>: Method for computing similarities, one of {:correlation, :euclidean, :cosine}.</li></ul><pre><code class="language-julia">eval_SC(Chat_train, cue_obj_train.C, cue_obj_val.C)
eval_SC(Chat_val, cue_obj_val.C, cue_obj_train.C)
eval_SC(Shat_train, S_train, S_val)
eval_SC(Shat_val, S_val, S_train)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantling/JudiLing.jl/blob/244bb0c648484065ffd5a41781ccc1caf2e5db60/src/eval.jl#LL303-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JudiLing.eval_SC-Tuple{AbstractArray, AbstractArray, DataFrames.DataFrame, Union{String, Symbol}}" href="#JudiLing.eval_SC-Tuple{AbstractArray, AbstractArray, DataFrames.DataFrame, Union{String, Symbol}}"><code>JudiLing.eval_SC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_SC(SChat::AbstractArray, SC::AbstractArray, data::DataFrame, target_col::Union{String, Symbol})</code></pre><p>Assess model accuracy on the basis of the correlations (or Euclidean distances or Cosine Similarities) of row vectors of Chat and C or Shat and S. Ideally the target words have highest correlations (lowest distance/highest similarity) on the diagonal of the pertinent correlation (distance/similarity) matrices. Support for homophones.</p><p>If <code>freq</code> is added, token-based accuracy is computed. Token-based accuracy weighs accuracy values according to words&#39; frequency, i.e. if a word has a frequency of 30 and overall there are 3000 tokens (the frequencies of all types sum to 3000), this token&#39;s accuracy will contribute 30/3000.</p><p><strong>Obligatory Arguments</strong></p><ul><li><code>SChat::Union{SparseMatrixCSC, Matrix}</code>: the Chat or Shat matrix</li><li><code>SC::Union{SparseMatrixCSC, Matrix}</code>: the C or S matrix</li><li><code>data::DataFrame</code>: datasets</li><li><code>target_col::Union{String, Symbol}</code>: target column name</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>digits</code>: the specified number of digits after the decimal place (or before if negative)</li><li><code>R::Bool=false</code>: if true, pairwise correlation/distance/similarity matrix R is return</li><li><code>freq::Union{Missing, Array{Int64, 1}, Array{Float64,1}}=missing</code>: list of frequencies of the wordforms in X and Y</li><li><code>method::Union{Symbol, String}=:correlation</code>: Method for computing similarities, one of {:correlation, :euclidean, :cosine}.</li></ul><pre><code class="language-julia">eval_SC(Chat_train, cue_obj_train.C, latin, :Word)
eval_SC(Chat_val, cue_obj_val.C, latin, :Word)
eval_SC(Shat_train, S_train, latin, :Word)
eval_SC(Shat_val, S_val, latin, :Word)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantling/JudiLing.jl/blob/244bb0c648484065ffd5a41781ccc1caf2e5db60/src/eval.jl#LL351-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JudiLing.eval_SC-Tuple{AbstractArray, AbstractArray, AbstractArray, DataFrames.DataFrame, DataFrames.DataFrame, Union{String, Symbol}}" href="#JudiLing.eval_SC-Tuple{AbstractArray, AbstractArray, AbstractArray, DataFrames.DataFrame, DataFrames.DataFrame, Union{String, Symbol}}"><code>JudiLing.eval_SC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_SC(SChat::AbstractArray, SC::AbstractArray, SC_rest::AbstractArray, data::DataFrame, data_rest::DataFrame, target_col::Union{String, Symbol})</code></pre><p>Assess model accuracy on the basis of the correlations (or Euclidean distances or Cosine Similarities) of row vectors of Chat and C or Shat and S. Ideally the target words have highest correlations (lowest distance/highest similarity) on the diagonal of the pertinent correlation (distance/similarity) matrices.</p><p>If <code>freq</code> is added, token-based accuracy is computed. Token-based accuracy weighs accuracy values according to words&#39; frequency, i.e. if a word has a frequency of 30 and overall there are 3000 tokens (the frequencies of all types sum to 3000), this token&#39;s accuracy will contribute 30/3000.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The order is important. The first gold standard matrix has to be corresponing to the SChat matrix, such as <code>eval_SC(Shat_train, S_train, S_val, latin, :Word)</code> or <code>eval_SC(Shat_val, S_val, S_train, latin, :Word)</code></p></div></div><p><strong>Obligatory Arguments</strong></p><ul><li><code>SChat::Union{SparseMatrixCSC, Matrix}</code>: the Chat or Shat matrix</li><li><code>SC::Union{SparseMatrixCSC, Matrix}</code>: the training/validation C or S matrix</li><li><code>SC_rest::Union{SparseMatrixCSC, Matrix}</code>: the validation/training C or S matrix</li><li><code>data::DataFrame</code>: the training/validation datasets</li><li><code>data_rest::DataFrame</code>: the validation/training datasets</li><li><code>target_col::Union{String, Symbol}</code>: target column name</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>digits</code>: the specified number of digits after the decimal place (or before if negative)</li><li><code>R::Bool=false</code>: if true, pairwise correlation/distance/similarity matrix R is return</li><li><code>freq::Union{Missing, Array{Int64, 1}, Array{Float64,1}}=missing</code>: list of frequencies of the wordforms in X and Y</li><li><code>method::Union{Symbol, String}=:correlation</code>: Method for computing similarities, one of {:correlation, :euclidean, :cosine}.</li></ul><pre><code class="language-julia">eval_SC(Chat_train, cue_obj_train.C, cue_obj_val.C, latin, :Word)
eval_SC(Chat_val, cue_obj_val.C, cue_obj_train.C, latin, :Word)
eval_SC(Shat_train, S_train, S_val, latin, :Word)
eval_SC(Shat_val, S_val, S_train, latin, :Word)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantling/JudiLing.jl/blob/244bb0c648484065ffd5a41781ccc1caf2e5db60/src/eval.jl#LL436-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JudiLing.eval_SC-Tuple{AbstractArray, AbstractArray, Int64}" href="#JudiLing.eval_SC-Tuple{AbstractArray, AbstractArray, Int64}"><code>JudiLing.eval_SC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_SC(SChat::AbstractArray, SC::AbstractArray, batch_size::Int64)</code></pre><p>Assess model accuracy on the basis of the correlations of row vectors of Chat and C or Shat and S. Ideally the target words have highest correlations on the diagonal of the pertinent correlation matrices. For large datasets, pass batch_size to process evaluation in chunks.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If there are homophones/homographs in the dataset, this evaluation method may be misleading: the predicted vector will be equally correlated with the target vector of both words and the one on the diagonal will not necessarily be selected as the most correlated. In such cases, supplying the dataset and target_col is recommended which enables taking into account homophones/homographs.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Currently only available for correlation.</p></div></div><p><strong>Obligatory Arguments</strong></p><ul><li><code>SChat</code>: the Chat or Shat matrix</li><li><code>SC</code>: the C or S matrix</li><li><code>data</code>: datasets</li><li><code>target_col</code>: target column name</li><li><code>batch_size</code>: batch size</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>digits</code>: the specified number of digits after the decimal place (or before if negative)</li><li><code>verbose::Bool=false</code>: if true, more information is printed</li></ul><pre><code class="language-julia">eval_SC(Chat_train, cue_obj_train.C, latin, :Word)
eval_SC(Chat_val, cue_obj_val.C, latin, :Word)
eval_SC(Shat_train, S_train, latin, :Word)
eval_SC(Shat_val, S_val, latin, :Word)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantling/JudiLing.jl/blob/244bb0c648484065ffd5a41781ccc1caf2e5db60/src/eval.jl#LL515-L546">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JudiLing.eval_SC-Tuple{AbstractArray, AbstractArray, DataFrames.DataFrame, Union{String, Symbol}, Int64}" href="#JudiLing.eval_SC-Tuple{AbstractArray, AbstractArray, DataFrames.DataFrame, Union{String, Symbol}, Int64}"><code>JudiLing.eval_SC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_SC(SChat::AbstractArray, SC::AbstractArray, data::DataFrame, target_col::Union{String, Symbol}, batch_size::Int64)</code></pre><p>Assess model accuracy on the basis of the correlations of row vectors of Chat and C or Shat and S. Ideally the target words have highest correlations on the diagonal of the pertinent correlation matrices. For large datasets, pass batch_size to process evaluation in chunks. Support homophones.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Currently only available for correlation.</p></div></div><p><strong>Obligatory Arguments</strong></p><ul><li><code>SChat::AbstractArray</code>: the Chat or Shat matrix</li><li><code>SC::AbstractArray</code>: the C or S matrix</li><li><code>data::DataFrame</code>: datasets</li><li><code>target_col::Union{String, Symbol}</code>: target column name</li><li><code>batch_size::Int64</code>: batch size</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>digits</code>: the specified number of digits after the decimal place (or before if negative)</li><li><code>verbose::Bool=false</code>: if true, more information is printed</li></ul><pre><code class="language-julia">eval_SC(Chat_train, cue_obj_train.C, latin, :Word, 5000)
eval_SC(Chat_val, cue_obj_val.C, latin, :Word, 5000)
eval_SC(Shat_train, S_train, latin, :Word, 5000)
eval_SC(Shat_val, S_val, latin, :Word, 5000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantling/JudiLing.jl/blob/244bb0c648484065ffd5a41781ccc1caf2e5db60/src/eval.jl#LL592-L620">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JudiLing.eval_SC_loose-Tuple{Any, Any, Any}" href="#JudiLing.eval_SC_loose-Tuple{Any, Any, Any}"><code>JudiLing.eval_SC_loose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_SC_loose(SChat, SC, k)</code></pre><p>Assess model accuracy on the basis of the correlations (or Euclidean distances or Cosine Similarities) of row vectors of Chat and C or Shat and S. Ideally the target words have highest correlations (lowest distance/highest similarity) on the diagonal of the pertinent correlation (distance/similarity) matrices. Count it as correct if one of the top k candidates is correct.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If there are homophones/homographs in the dataset, this evaluation method may be misleading: the predicted vector will be equally correlated with the target vector of both words and it is not guaranteed that the target on the diagonal will be among the k neighbours. In particular, <code>eval_SC</code> and <code>eval_SC_loose</code> with k=1 are not guaranteed to give the same result. In such cases, supplying the dataset and <code>target_col</code> is recommended which enables taking into account homophones/homographs.</p></div></div><p><strong>Obligatory Arguments</strong></p><ul><li><code>SChat::Union{SparseMatrixCSC, Matrix}</code>: the Chat or Shat matrix</li><li><code>SC::Union{SparseMatrixCSC, Matrix}</code>: the C or S matrix</li><li><code>k</code>: top k candidates</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>digits</code>: the specified number of digits after the decimal place (or before if negative)</li><li><code>method::Union{Symbol, String}=:correlation</code>: Method for computing similarities, one of {:correlation, :euclidean, :cosine}.</li></ul><pre><code class="language-julia">eval_SC_loose(Chat, cue_obj.C, k)
eval_SC_loose(Shat, S, k)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantling/JudiLing.jl/blob/244bb0c648484065ffd5a41781ccc1caf2e5db60/src/eval.jl#LL698-L721">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JudiLing.eval_SC_loose-NTuple{5, Any}" href="#JudiLing.eval_SC_loose-NTuple{5, Any}"><code>JudiLing.eval_SC_loose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_SC_loose(SChat, SC, k, data, target_col)</code></pre><p>Assess model accuracy on the basis of the correlations (or Euclidean distances or Cosine Similarities) of row vectors of Chat and C or Shat and S. Ideally the target words have highest correlations (lowest distance/highest similarity) on the diagonal of the pertinent correlation (distance/similarity) matrices. Count it as correct if one of the top k candidates is correct. Support for homophones.</p><p><strong>Obligatory Arguments</strong></p><ul><li><code>SChat::Union{SparseMatrixCSC, Matrix}</code>: the Chat or Shat matrix</li><li><code>SC::Union{SparseMatrixCSC, Matrix}</code>: the C or S matrix</li><li><code>k</code>: top k candidates</li><li><code>data</code>: datasets</li><li><code>target_col</code>: target column name</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>digits</code>: the specified number of digits after the decimal place (or before if negative)</li><li><code>method::Union{Symbol, String}=:correlation</code>: Method for computing similarities, one of {:correlation, :euclidean, :cosine}.</li></ul><pre><code class="language-julia">eval_SC_loose(Chat, cue_obj.C, k, latin, :Word)
eval_SC_loose(Shat, S, k, latin, :Word)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantling/JudiLing.jl/blob/244bb0c648484065ffd5a41781ccc1caf2e5db60/src/eval.jl#LL768-L791">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JudiLing.eval_manual-Tuple{Any, Any, Any}" href="#JudiLing.eval_manual-Tuple{Any, Any, Any}"><code>JudiLing.eval_manual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_manual(res, data, i2f)</code></pre><p>Create extensive reports for the outputs from <code>build_paths</code> and <code>learn_paths</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantling/JudiLing.jl/blob/244bb0c648484065ffd5a41781ccc1caf2e5db60/src/eval.jl#LL921-L925">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JudiLing.eval_acc-Tuple{Any, Array}" href="#JudiLing.eval_acc-Tuple{Any, Array}"><code>JudiLing.eval_acc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_acc(res, gold_inds::Array)</code></pre><p>Evaluate the accuracy of the results from <code>learn_paths</code> or <code>build_paths</code>.</p><p><strong>Obligatory Arguments</strong></p><ul><li><code>res::Array</code>: the results from <code>learn_paths</code> or <code>build_paths</code></li><li><code>gold_inds::Array</code>: the gold paths&#39; indices</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>digits</code>: the specified number of digits after the decimal place (or before if negative)</li><li><code>verbose::Bool=false</code>: if true, more information is printed</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia"># evaluation on training data
acc_train = JudiLing.eval_acc(
    res_train,
    cue_obj_train.gold_ind,
    verbose=false
)

# evaluation on validation data
acc_val = JudiLing.eval_acc(
    res_val,
    cue_obj_val.gold_ind,
    verbose=false
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantling/JudiLing.jl/blob/244bb0c648484065ffd5a41781ccc1caf2e5db60/src/eval.jl#LL967-L996">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JudiLing.eval_acc-Tuple{Any, JudiLing.Cue_Matrix_Struct}" href="#JudiLing.eval_acc-Tuple{Any, JudiLing.Cue_Matrix_Struct}"><code>JudiLing.eval_acc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_acc(res, cue_obj::Cue_Matrix_Struct)</code></pre><p>Evaluate the accuracy of the results from <code>learn_paths</code> or <code>build_paths</code>.</p><p><strong>Obligatory Arguments</strong></p><ul><li><code>res::Array</code>: the results from <code>learn_paths</code> or <code>build_paths</code></li><li><code>cue_obj::Cue_Matrix_Struct</code>: the C matrix object</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>digits</code>: the specified number of digits after the decimal place (or before if negative)</li><li><code>verbose::Bool=false</code>: if true, more information is printed</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">acc = JudiLing.eval_acc(res, cue_obj)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantling/JudiLing.jl/blob/244bb0c648484065ffd5a41781ccc1caf2e5db60/src/eval.jl#LL1020-L1037">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JudiLing.eval_acc_loose-Tuple{Any, Any}" href="#JudiLing.eval_acc_loose-Tuple{Any, Any}"><code>JudiLing.eval_acc_loose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eval_acc_loose(res, gold_inds)</code></pre><p>Lenient evaluation of the accuracy of the results from <code>learn_paths</code> or <code>build_paths</code>, counting a prediction as correct when the correlation of the predicted and gold standard semantic vectors is among the n top correlations, where n is equal to <code>max_can</code> in the &#39;learn<em>paths&#39; or `build</em>paths` function.</p><p><strong>Obligatory Arguments</strong></p><ul><li><code>res::Array</code>: the results from <code>learn_paths</code> or <code>build_paths</code></li><li><code>gold_inds::Array</code>: the gold paths&#39; indices</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>digits</code>: the specified number of digits after the decimal place (or before if negative)</li><li><code>verbose::Bool=false</code>: if true, more information is printed</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia"># evaluation on training data
acc_train_loose = JudiLing.eval_acc_loose(
    res_train,
    cue_obj_train.gold_ind,
    verbose=false
)

# evaluation on validation data
acc_val_loose = JudiLing.eval_acc_loose(
    res_val,
    cue_obj_val.gold_ind,
    verbose=false
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantling/JudiLing.jl/blob/244bb0c648484065ffd5a41781ccc1caf2e5db60/src/eval.jl#LL1042-L1074">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JudiLing.extract_gpi" href="#JudiLing.extract_gpi"><code>JudiLing.extract_gpi</code></a> — <span class="docstring-category">Function</span></header><section><div><p>extract_gpi(gpi, threshold=0.1, tolerance=(-1000.0))</p><p>Extract, using gold paths&#39; information, how many n-grams for a gold path are below the threshold but above the tolerance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quantling/JudiLing.jl/blob/244bb0c648484065ffd5a41781ccc1caf2e5db60/src/eval.jl#LL1104-L1109">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../find_path/">« Find Paths</a><a class="docs-footer-nextpage" href="../output/">Output »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 3 July 2024 16:02">Wednesday 3 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
