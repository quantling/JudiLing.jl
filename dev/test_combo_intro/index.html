<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Test Combo Introduction · JudiLing.jl</title><link rel="canonical" href="https://MegamindHenry.github.io/JudiLing.jl/test_combo_intro/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JudiLing.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Test Combo Introduction</a><ul class="internal"><li><a class="tocitem" href="#Split-mode"><span>Split mode</span></a></li><li><a class="tocitem" href="#Training-and-validation-size"><span>Training and validation size</span></a></li><li><a class="tocitem" href="#Make-cue-matrix"><span>Make cue matrix</span></a></li><li><a class="tocitem" href="#Make-S-matrix"><span>Make S matrix</span></a></li><li><a class="tocitem" href="#Learning-mode"><span>Learning mode</span></a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../man/make_cue_matrix/">Make Cue Matrix</a></li><li><a class="tocitem" href="../man/make_semantic_matrix/">Make Semantic Matrix</a></li><li><a class="tocitem" href="../man/cholesky/">Cholesky</a></li><li><a class="tocitem" href="../man/make_adjacency_matrix/">Make Adjacency Matrix</a></li><li><a class="tocitem" href="../man/make_yt_matrix/">Make Yt Matrix</a></li><li><a class="tocitem" href="../man/find_path/">Find Paths</a></li><li><a class="tocitem" href="../man/eval/">Evaluation</a></li><li><a class="tocitem" href="../man/output/">Output</a></li><li><a class="tocitem" href="../man/test_combo/">Test Combo</a></li><li><a class="tocitem" href="../man/display/">Display</a></li><li><a class="tocitem" href="../man/utils/">Utils</a></li><li><a class="tocitem" href="../man/pickle/">Pickle</a></li><li><a class="tocitem" href="../man/pyndl/">Pyndl</a></li><li><a class="tocitem" href="../man/wh/">Widrow-Hoff Learning</a></li></ul></li><li><a class="tocitem" href="../man/all_manual/">All Manual index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Test Combo Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Test Combo Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MegamindHenry/JudiLing.jl/blob/master/docs/src/test_combo_intro.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Test-Combo-Introduction"><a class="docs-heading-anchor" href="#Test-Combo-Introduction">Test Combo Introduction</a><a id="Test-Combo-Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Test-Combo-Introduction" title="Permalink"></a></h1><p>We implemented a high-level wrapper function that aims to provide quick and preliminary studies on multiple datasets with different parameter settings. For a sophisticated study, we suggest to build a script step by step.</p><h2 id="Split-mode"><a class="docs-heading-anchor" href="#Split-mode">Split mode</a><a id="Split-mode-1"></a><a class="docs-heading-anchor-permalink" href="#Split-mode" title="Permalink"></a></h2><p><code>test_combo</code> function provides four split mode. <code>:train_only</code> give the opportunity to only evaluate the model with training data or partial training data. <code>data_path</code> is the path to the CSV file and <code>data_output_dir</code> is the directory for store training and validation datasets for future analysis.</p><pre><code class="language-julia">JudiLing.test_combo(
    :train_only,
    data_path = joinpath(@__DIR__, &quot;data&quot;, &quot;latin.csv&quot;),
    data_prefix = &quot;latin&quot;,
    data_output_dir = joinpath(@__DIR__, &quot;data&quot;),
    n_grams_target_col = :Word,
    n_grams_tokenized = false,
    grams = 3,
    n_features_base = [&quot;Lexeme&quot;],
    n_features_inflections = [&quot;Person&quot;,&quot;Number&quot;,&quot;Tense&quot;,&quot;Voice&quot;,&quot;Mood&quot;],
    verbose = true
    )</code></pre><p><code>:pre_split</code> give the option for datasets that already have been split into train and validation datasets. <code>data_path</code> is the path to the directory containing CSV files.</p><pre><code class="language-julia">JudiLing.test_combo(
    :pre_split,
    data_path=joinpath(@__DIR__, &quot;data&quot;),
    data_prefix=&quot;estonian&quot;,
    n_grams_target_col=:Word,
    n_grams_tokenized=false,
    grams=3,
    n_features_base = [&quot;Lexeme&quot;],
    n_features_inflections = [&quot;Lexeme&quot;,&quot;Case&quot;,&quot;Number&quot;],
    A_mode = :train_only,
    threshold_train = 0.1,
    is_tolerant_train = false,
    threshold_val = 0.1,
    is_tolerant_val = true,
    tolerance_val = -0.1,
    max_tolerance_val = 3,
    verbose = true
    )</code></pre><p><code>:random_split</code> will randomly split data into training and validation datasets. In this case, it is high likely that unseen n-grams and features are in the validation datasets. Therefore, <code>if_combined</code> should be turned on. <code>data_path</code> is the path to the directory containing CSV files and <code>data_output_dir</code> is the directory for store training and validation datasets for future analysis.</p><pre><code class="language-julia">JudiLing.test_combo(
    :random_split,
    val_sample_size = 1000,
    data_path = joinpath(@__DIR__, &quot;data&quot;, &quot;french.csv&quot;),
    data_prefix = &quot;french&quot;,
    data_output_dir = joinpath(@__DIR__, &quot;data&quot;),
    n_grams_target_col = :Syllables,
    n_grams_tokenized = true,
    n_grams_sep_token = &quot;-&quot;,
    n_grams_keep_sep = true,
    grams = 2,
    n_features_base = [&quot;Lexeme&quot;],
    n_features_inflections = [&quot;Tense&quot;,&quot;Aspect&quot;,&quot;Person&quot;,&quot;Number&quot;,&quot;Gender&quot;,&quot;Class&quot;,&quot;Mood&quot;],
    if_combined = true,
    threshold_train = 0.1,
    is_tolerant_train = false,
    is_tolerant_val = true,
    threshold_val = 0.1,
    tolerance_val = -0.1,
    max_tolerance_train = 3,
    verbose = true
    )</code></pre><p><code>:careful_split</code> will carefully split data into training and validation datasets where there will be no unseen n-grams and features in the validation datasets. Therefore, <code>if_combined</code> shall be truned off. <code>data_path</code> is the path to the directory containing CSV files and <code>data_output_dir</code> is the directory for store training and validation datasets for future analysis. <code>n_features_columns</code> gives names of feature columns and target column.</p><pre><code class="language-julia">JudiLing.test_combo(
    :careful_split,
    val_sample_size = 1000,
    data_path = joinpath(@__DIR__, &quot;data&quot;, &quot;french.csv&quot;),
    data_prefix = &quot;french&quot;,
    data_output_dir = joinpath(@__DIR__, &quot;data&quot;),
    n_features_columns = [&quot;Lexeme&quot;,&quot;Tense&quot;,&quot;Aspect&quot;,&quot;Person&quot;,&quot;Number&quot;,&quot;Gender&quot;,&quot;Class&quot;,&quot;Mood&quot;],
    n_grams_target_col = :Syllables,
    n_grams_tokenized = true,
    n_grams_sep_token = &quot;-&quot;,
    n_grams_keep_sep = true,
    grams = 2,
    n_features_base = [&quot;Lexeme&quot;],
    n_features_inflections = [&quot;Tense&quot;,&quot;Aspect&quot;,&quot;Person&quot;,&quot;Number&quot;,&quot;Gender&quot;,&quot;Class&quot;,&quot;Mood&quot;],
    if_combined = true,
    threshold_train = 0.1,
    is_tolerant_train = false,
    is_tolerant_val = true,
    threshold_val = 0.1,
    tolerance_val = -0.1,
    max_tolerance_train = 3,
    verbose = true
    )</code></pre><h2 id="Training-and-validation-size"><a class="docs-heading-anchor" href="#Training-and-validation-size">Training and validation size</a><a id="Training-and-validation-size-1"></a><a class="docs-heading-anchor-permalink" href="#Training-and-validation-size" title="Permalink"></a></h2><p><code>val_sample_size</code> and <code>val_ratio</code> control the validation data size. <code>train_sample_size</code> controls the training data size. For very large datasets, it is recommended that try out with small <code>train_sample_size</code> first, then test out the whole dataset.</p><pre><code class="language-julia">JudiLing.test_combo(
    :random_split,
    train_sample_size = 3000,
    val_sample_size = 100,
    data_path = joinpath(@__DIR__, &quot;data&quot;, &quot;french.csv&quot;),
    data_prefix = &quot;french&quot;,
    data_output_dir = joinpath(@__DIR__, &quot;data&quot;),
    n_features_columns = [&quot;Lexeme&quot;,&quot;Tense&quot;,&quot;Aspect&quot;,&quot;Person&quot;,&quot;Number&quot;,&quot;Gender&quot;,&quot;Class&quot;,&quot;Mood&quot;],
    n_grams_target_col = :Syllables,
    n_grams_tokenized = true,
    n_grams_sep_token = &quot;-&quot;,
    n_grams_keep_sep = true,
    grams = 2,
    n_features_base = [&quot;Lexeme&quot;],
    n_features_inflections = [&quot;Tense&quot;,&quot;Aspect&quot;,&quot;Person&quot;,&quot;Number&quot;,&quot;Gender&quot;,&quot;Class&quot;,&quot;Mood&quot;],
    if_combined = true,
    threshold_train = 0.1,
    is_tolerant_train = false,
    is_tolerant_val = true,
    threshold_val = 0.1,
    tolerance_val = -0.1,
    max_tolerance_train = 3,
    verbose = true
    )

JudiLing.test_combo(
    :random_split,
    val_ratio = 0.1,
    data_path = joinpath(@__DIR__, &quot;data&quot;, &quot;french.csv&quot;),
    data_prefix = &quot;french&quot;,
    data_output_dir = joinpath(@__DIR__, &quot;data&quot;),
    n_features_columns = [&quot;Lexeme&quot;,&quot;Tense&quot;,&quot;Aspect&quot;,&quot;Person&quot;,&quot;Number&quot;,&quot;Gender&quot;,&quot;Class&quot;,&quot;Mood&quot;],
    n_grams_target_col = :Syllables,
    n_grams_tokenized = true,
    n_grams_sep_token = &quot;-&quot;,
    n_grams_keep_sep = true,
    grams = 2,
    n_features_base = [&quot;Lexeme&quot;],
    n_features_inflections = [&quot;Tense&quot;,&quot;Aspect&quot;,&quot;Person&quot;,&quot;Number&quot;,&quot;Gender&quot;,&quot;Class&quot;,&quot;Mood&quot;],
    if_combined = true,
    threshold_train = 0.1,
    is_tolerant_train = false,
    is_tolerant_val = true,
    threshold_val = 0.1,
    tolerance_val = -0.1,
    max_tolerance_train = 3,
    verbose = true
    )</code></pre><h2 id="Make-cue-matrix"><a class="docs-heading-anchor" href="#Make-cue-matrix">Make cue matrix</a><a id="Make-cue-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Make-cue-matrix" title="Permalink"></a></h2><p>Parameters for making cue matrix object is same as <code>make_cue_matrix</code> function:</p><ul><li><code>grams::Int64=3</code>: the number of grams for cues</li><li><code>n_grams_target_col::Union{String, Symbol}=:Words</code>: the column name for target strings</li><li><code>n_grams_tokenized::Bool=false</code>:if true, the dataset target is assumed to be tokenized</li><li><code>n_grams_sep_token::Union{Nothing, String, Char}=nothing</code>: separator</li><li><code>n_grams_keep_sep::Bool=false</code>: if true, keep separators in cues</li><li><code>start_end_token::Union{String, Char}=&quot;#&quot;</code>: start and end token in boundary cues</li></ul><pre><code class="language-julia">JudiLing.test_combo(
    :train_only,
    data_path = joinpath(@__DIR__, &quot;data&quot;, &quot;latin.csv&quot;),
    data_prefix = &quot;latin&quot;,
    data_output_dir = joinpath(@__DIR__, &quot;data&quot;),
    n_features_columns = [&quot;Lexeme&quot;,&quot;Person&quot;,&quot;Number&quot;,&quot;Tense&quot;,&quot;Voice&quot;,&quot;Mood&quot;],
    n_grams_target_col = :Word,
    n_grams_tokenized = false,
    n_grams_sep_token = nothing,
    n_grams_keep_sep = false,
    grams = 3,
    start_end_token = &quot;#&quot;,
    n_features_base = [&quot;Lexeme&quot;],
    n_features_inflections = [&quot;Person&quot;,&quot;Number&quot;,&quot;Tense&quot;,&quot;Voice&quot;,&quot;Mood&quot;],
    verbose = true
    )

JudiLing.test_combo(
    :random_split,
    val_sample_size = 1000,
    data_path = joinpath(@__DIR__, &quot;data&quot;, &quot;french.csv&quot;),
    data_prefix = &quot;french&quot;,
    data_output_dir = joinpath(@__DIR__, &quot;data&quot;),
    n_features_columns = [&quot;Lexeme&quot;,&quot;Tense&quot;,&quot;Aspect&quot;,&quot;Person&quot;,&quot;Number&quot;,&quot;Gender&quot;,&quot;Class&quot;,&quot;Mood&quot;],
    n_grams_target_col = :Syllables,
    n_grams_tokenized = true,
    n_grams_sep_token = &quot;-&quot;,
    n_grams_keep_sep = true,
    grams = 2,
    n_features_base = [&quot;Lexeme&quot;],
    n_features_inflections = [&quot;Tense&quot;,&quot;Aspect&quot;,&quot;Person&quot;,&quot;Number&quot;,&quot;Gender&quot;,&quot;Class&quot;,&quot;Mood&quot;],
    if_combined = true,
    threshold_train = 0.1,
    is_tolerant_train = false,
    is_tolerant_val = true,
    threshold_val = 0.1,
    tolerance_val = -0.1,
    max_tolerance_train = 3,
    verbose = true
    )</code></pre><h2 id="Make-S-matrix"><a class="docs-heading-anchor" href="#Make-S-matrix">Make S matrix</a><a id="Make-S-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Make-S-matrix" title="Permalink"></a></h2><p>Parameters for making S matrix is the same as <code>make_S_matrix</code>:</p><ul><li><code>n_features_base::Vector</code>: context lexemes</li><li><code>n_features_inflections::Vector</code>: grammatic lexemes</li><li><code>sd_base_mean::Int64=1</code>: the sd mean of base features</li><li><code>sd_inflection_mean::Int64=1</code>: the sd mean of inflectional features</li><li><code>sd_base::Int64=4</code>: the sd of base features</li><li><code>sd_inflection::Int64=4</code>: the sd of inflectional features</li><li><code>isdeep::Bool=true</code>: if true, mean of each feature is also randomized</li><li><code>add_noise::Bool=true</code>: if true, add additional Gaussian noise</li><li><code>sd_noise::Int64=1</code>: the sd of the Gaussian noise</li><li><code>normalized::Bool=false</code>: if true, most of the values range between 1 and -1, it may slightly exceed between 1 or -1 depending on the sd</li></ul><pre><code class="language-julia">JudiLing.test_combo(
    :train_only,
    data_path = joinpath(@__DIR__, &quot;data&quot;, &quot;latin.csv&quot;),
    data_prefix = &quot;latin&quot;,
    data_output_dir = joinpath(@__DIR__, &quot;data&quot;),
    n_grams_target_col = :Word,
    n_grams_tokenized = false,
    grams = 3,
    n_features_base = [&quot;Lexeme&quot;],
    n_features_inflections = [&quot;Person&quot;,&quot;Number&quot;,&quot;Tense&quot;,&quot;Voice&quot;,&quot;Mood&quot;],
    sd_base_mean = 1,
    sd_inflection_mean = 1,
    sd_base = 4,
    sd_inflection = 4,
    isdeep = true,
    add_noise = true,
    sd_noise = 1,
    normalized = false,
    verbose = true
    )</code></pre><h2 id="Learning-mode"><a class="docs-heading-anchor" href="#Learning-mode">Learning mode</a><a id="Learning-mode-1"></a><a class="docs-heading-anchor-permalink" href="#Learning-mode" title="Permalink"></a></h2><p>Currently <code>test_combo</code> function supports two learning mode by <code>learn_mode</code>, <code>:wh</code> for increamental learning implemented Widrow-Hoff learning rules and <code>:cholesky</code> for end-state learning using Cholesky Decomposition.</p><h3 id="Cholesky"><a class="docs-heading-anchor" href="#Cholesky">Cholesky</a><a id="Cholesky-1"></a><a class="docs-heading-anchor-permalink" href="#Cholesky" title="Permalink"></a></h3><p>Parameters for Cholesky mode are:</p><ul><li><code>method::Symbol = :additive</code>: whether :additive or :multiplicative decomposition is required</li><li><code>shift::Float64 = 0.02</code>: shift value for :additive decomposition</li><li><code>multiplier::Float64 = 1.01</code>: multiplier value for :multiplicative decomposition</li><li><code>output_format::Symbol = :auto</code>: to force output format to dense(:dense) or sparse(:sparse), make it auto(:auto) to determined by the program</li><li><code>sparse_ratio::Float64 = 0.2</code>: the ratio to decide whether a matrix is sparse</li></ul><pre><code class="language-julia">JudiLing.test_combo(
    :train_only,
    data_path = joinpath(@__DIR__, &quot;data&quot;, &quot;latin.csv&quot;),
    data_prefix = &quot;latin&quot;,
    data_output_dir = joinpath(@__DIR__, &quot;data&quot;),
    n_grams_target_col = :Word,
    n_grams_tokenized = false,
    grams = 3,
    n_features_base = [&quot;Lexeme&quot;],
    n_features_inflections = [&quot;Person&quot;,&quot;Number&quot;,&quot;Tense&quot;,&quot;Voice&quot;,&quot;Mood&quot;],
    learn_mode = :cholesky,
    method = :additive,
    shift = 0.02,
    output_format = :auto,
    sparse_ratio = 0.2,
    verbose = true
    )</code></pre><h3 id="Widrow-Hoff-learning"><a class="docs-heading-anchor" href="#Widrow-Hoff-learning">Widrow-Hoff learning</a><a id="Widrow-Hoff-learning-1"></a><a class="docs-heading-anchor-permalink" href="#Widrow-Hoff-learning" title="Permalink"></a></h3><p>Parameters for Widrow-Hoff learning are:</p><ul><li><code>wh_freq::Vector = nothing</code>: the learning sequence</li><li><code>init_weights::Matrix = nothing</code>: the initial weights</li><li><code>eta::Float64 = 0.1</code>: the learning rate</li><li><code>n_epochs::Int64 = 1</code>: the number of epochs to be trained</li></ul><pre><code class="language-julia">JudiLing.test_combo(
    :train_only,
    data_path = joinpath(@__DIR__, &quot;data&quot;, &quot;latin.csv&quot;),
    data_prefix = &quot;latin&quot;,
    data_output_dir = joinpath(@__DIR__, &quot;data&quot;),
    n_grams_target_col = :Word,
    n_grams_tokenized = false,
    grams = 3,
    n_features_base = [&quot;Lexeme&quot;],
    n_features_inflections = [&quot;Person&quot;,&quot;Number&quot;,&quot;Tense&quot;,&quot;Voice&quot;,&quot;Mood&quot;],
    learn_mode = :wh,
    eta = 0.001,
    n_epochs = 1000,
    verbose = true
    )</code></pre><h3 id="Adjacency-matrix"><a class="docs-heading-anchor" href="#Adjacency-matrix">Adjacency matrix</a><a id="Adjacency-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Adjacency-matrix" title="Permalink"></a></h3><p><code>test_combo</code> has control (<code>A_mode</code>) for whether to take combined adjacency matrix (<code>:combined</code>). In that case, the adjacency matrix is made from both training and validation matrix, otherwise the adjacency matrix is only made from training data (<code>:train_only</code>). There is also an option to pass custumized adjacency matrix (<code>A</code>).</p><pre><code class="language-julia">JudiLing.test_combo(
    :random_split,
    val_sample_size = 1000,
    data_path = joinpath(@__DIR__, &quot;data&quot;, &quot;french.csv&quot;),
    data_prefix = &quot;french&quot;,
    data_output_dir = joinpath(@__DIR__, &quot;data&quot;),
    n_features_columns = [&quot;Lexeme&quot;,&quot;Tense&quot;,&quot;Aspect&quot;,&quot;Person&quot;,&quot;Number&quot;,&quot;Gender&quot;,&quot;Class&quot;,&quot;Mood&quot;],
    n_grams_target_col = :Syllables,
    n_grams_tokenized = true,
    n_grams_sep_token = &quot;-&quot;,
    n_grams_keep_sep = true,
    grams = 2,
    n_features_base = [&quot;Lexeme&quot;],
    n_features_inflections = [&quot;Tense&quot;,&quot;Aspect&quot;,&quot;Person&quot;,&quot;Number&quot;,&quot;Gender&quot;,&quot;Class&quot;,&quot;Mood&quot;],
    if_combined = true,
    A_mode = :combined,
    threshold_train = 0.1,
    is_tolerant_train = false,
    is_tolerant_val = true,
    threshold_val = 0.1,
    tolerance_val = -0.1,
    max_tolerance_train = 3,
    verbose = true
    )

# suppose we had A matrix from somewhere else
JudiLing.test_combo(
    :random_split,
    val_sample_size = 1000,
    data_path = joinpath(@__DIR__, &quot;data&quot;, &quot;french.csv&quot;),
    data_prefix = &quot;french&quot;,
    data_output_dir = joinpath(@__DIR__, &quot;data&quot;),
    n_features_columns = [&quot;Lexeme&quot;,&quot;Tense&quot;,&quot;Aspect&quot;,&quot;Person&quot;,&quot;Number&quot;,&quot;Gender&quot;,&quot;Class&quot;,&quot;Mood&quot;],
    n_grams_target_col = :Syllables,
    n_grams_tokenized = true,
    n_grams_sep_token = &quot;-&quot;,
    n_grams_keep_sep = true,
    grams = 2,
    n_features_base = [&quot;Lexeme&quot;],
    n_features_inflections = [&quot;Tense&quot;,&quot;Aspect&quot;,&quot;Person&quot;,&quot;Number&quot;,&quot;Gender&quot;,&quot;Class&quot;,&quot;Mood&quot;],
    if_combined = true,
    A = A,
    threshold_train = 0.1,
    is_tolerant_train = false,
    is_tolerant_val = true,
    threshold_val = 0.1,
    tolerance_val = -0.1,
    max_tolerance_train = 3,
    verbose = true
    )</code></pre><h3 id="learn_paths"><a class="docs-heading-anchor" href="#learn_paths"><code>learn_paths</code></a><a id="learn_paths-1"></a><a class="docs-heading-anchor-permalink" href="#learn_paths" title="Permalink"></a></h3><p>We have separate parameters for training and validation data:</p><ul><li><code>threshold_train::Float64 = 0.1</code>: the value set for the support such that if the support of an n-gram is higher than this value, the n-gram will be taking into consideration</li><li><code>is_tolerant_train::Bool = false</code>: if true, select a specified number (given by <code>max_tolerance</code>) of n-grams whose supports are below threshold but above a second tolerance threshold to be added to the path</li><li><code>tolerance_train::Float64 = -0.1</code>: the value set for the second threshold (in tolerant mode) such that if the support for an n-gram is in between this value and the threshold and the max_tolerance number has not been reached, then allow this n-gram to be added to the path</li><li><code>max_tolerance_train::Int64 = 2</code>: maximum number of n-grams allowed in a path</li><li><code>threshold_val::Float64 = 0.1</code>: the value set for the support such that if the support of an n-gram is higher than this value, the n-gram will be taking into consideration</li><li><code>is_tolerant_val::Bool = false</code>: if true, select a specified number (given by <code>max_tolerance</code>) of n-grams whose supports are below threshold but above a second tolerance threshold to be added to the path</li><li><code>tolerance_val::Float64 = -0.1</code>: the value set for the second threshold (in tolerant mode) such that if the support for an n-gram is in between this value and the threshold and the max_tolerance number has not been reached, then allow this n-gram to be added to the path</li><li><code>max_tolerance_val::Int64 = 2</code>: maximum number of n-grams allowed in a path</li></ul><pre><code class="language-julia">JudiLing.test_combo(
    :random_split,
    train_sample_size = 3000,
    val_sample_size = 100,
    data_path = joinpath(@__DIR__, &quot;data&quot;, &quot;french.csv&quot;),
    data_prefix = &quot;french&quot;,
    data_output_dir = joinpath(@__DIR__, &quot;data&quot;),
    n_features_columns = [&quot;Lexeme&quot;,&quot;Tense&quot;,&quot;Aspect&quot;,&quot;Person&quot;,&quot;Number&quot;,&quot;Gender&quot;,&quot;Class&quot;,&quot;Mood&quot;],
    n_grams_target_col = :Syllables,
    n_grams_tokenized = true,
    n_grams_sep_token = &quot;-&quot;,
    n_grams_keep_sep = true,
    grams = 2,
    n_features_base = [&quot;Lexeme&quot;],
    n_features_inflections = [&quot;Tense&quot;,&quot;Aspect&quot;,&quot;Person&quot;,&quot;Number&quot;,&quot;Gender&quot;,&quot;Class&quot;,&quot;Mood&quot;],
    if_combined = true,
    threshold_train = 0.1,
    is_tolerant_train = false,
    is_tolerant_val = true,
    threshold_val = 0.1,
    tolerance_val = -0.1,
    max_tolerance_train = 3,
    verbose = true
    )</code></pre><h3 id="build_paths"><a class="docs-heading-anchor" href="#build_paths"><code>build_paths</code></a><a id="build_paths-1"></a><a class="docs-heading-anchor-permalink" href="#build_paths" title="Permalink"></a></h3><p>We have separate parameters for training and validation data:</p><ul><li><code>n_neighbors_train::Int64 = 10</code>: the top n form neighbors to be considered</li><li><code>n_neighbors_val::Int64 = 20</code>: the top n form neighbors to be considered</li></ul><pre><code class="language-julia">JudiLing.test_combo(
    :random_split,
    train_sample_size = 3000,
    val_sample_size = 100,
    data_path = joinpath(@__DIR__, &quot;data&quot;, &quot;french.csv&quot;),
    data_prefix = &quot;french&quot;,
    data_output_dir = joinpath(@__DIR__, &quot;data&quot;),
    n_features_columns = [&quot;Lexeme&quot;,&quot;Tense&quot;,&quot;Aspect&quot;,&quot;Person&quot;,&quot;Number&quot;,&quot;Gender&quot;,&quot;Class&quot;,&quot;Mood&quot;],
    n_grams_target_col = :Syllables,
    n_grams_tokenized = true,
    n_grams_sep_token = &quot;-&quot;,
    n_grams_keep_sep = true,
    grams = 2,
    n_features_base = [&quot;Lexeme&quot;],
    n_features_inflections = [&quot;Tense&quot;,&quot;Aspect&quot;,&quot;Person&quot;,&quot;Number&quot;,&quot;Gender&quot;,&quot;Class&quot;,&quot;Mood&quot;],
    if_combined = true,
    n_neighbors_train = 10,
    n_neighbors_val = 20,
    verbose = true
    )</code></pre><h3 id="Output-directory"><a class="docs-heading-anchor" href="#Output-directory">Output directory</a><a id="Output-directory-1"></a><a class="docs-heading-anchor-permalink" href="#Output-directory" title="Permalink"></a></h3><p>All outputs will be stored in a directory which can be configured by <code>output_dir</code>.</p><pre><code class="language-julia">JudiLing.test_combo(
    :train_only,
    data_path = joinpath(@__DIR__, &quot;data&quot;, &quot;latin.csv&quot;),
    data_prefix = &quot;latin&quot;,
    data_output_dir = joinpath(@__DIR__, &quot;data&quot;),
    n_grams_target_col = :Word,
    n_grams_tokenized = false,
    grams = 3,
    n_features_base = [&quot;Lexeme&quot;],
    n_features_inflections = [&quot;Person&quot;,&quot;Number&quot;,&quot;Tense&quot;,&quot;Voice&quot;,&quot;Mood&quot;],
    output_dir = joinpath(@__DIR__, &quot;latin_out&quot;),
    verbose = true
    )</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../man/make_cue_matrix/">Make Cue Matrix »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 22 March 2021 15:11">Monday 22 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
