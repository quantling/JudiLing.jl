var documenterSearchIndex = {"docs":
[{"location":"man/pickle/","page":"Utils","title":"Utils","text":"CurrentModule = JudiLing","category":"page"},{"location":"man/pickle/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"man/pickle/","page":"Utils","title":"Utils","text":"  mypickle\n  myunpickle","category":"page"},{"location":"man/pickle/#JudiLing.mypickle","page":"Utils","title":"JudiLing.mypickle","text":"save pickle from python pickle file\n\n\n\n\n\n","category":"function"},{"location":"man/pickle/#JudiLing.myunpickle","page":"Utils","title":"JudiLing.myunpickle","text":"load pickle from python pickle file\n\n\n\n\n\n","category":"function"},{"location":"man/utils/","page":"Utils","title":"Utils","text":"CurrentModule = JudiLing","category":"page"},{"location":"man/utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"man/utils/","page":"Utils","title":"Utils","text":"  iscorrect\n  display_pred\n  translate\n  translate_path\n  is_truly_sparse\n  isattachable\n  iscomplete\n  isstart\n  isnovel\n  check_used_token\n  cal_max_timestep","category":"page"},{"location":"man/utils/#JudiLing.iscorrect","page":"Utils","title":"JudiLing.iscorrect","text":"check whether the prediction is correct\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#JudiLing.display_pred","page":"Utils","title":"JudiLing.display_pred","text":"display prediction nicely\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#JudiLing.translate","page":"Utils","title":"JudiLing.translate","text":"translate indices into words or utterances\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#JudiLing.translate_path","page":"Utils","title":"JudiLing.translate_path","text":"just append indices together\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#JudiLing.is_truly_sparse","page":"Utils","title":"JudiLing.is_truly_sparse","text":"check whether a matrix is truly sparse regardless its format\n\n\n\n\n\ncheck whether a matrix is truly sparse regardless its format\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#JudiLing.isattachable","page":"Utils","title":"JudiLing.isattachable","text":"check a gram is attach to another gram\n\n\n\n\n\ncheck a gram is attach to another gram\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#JudiLing.iscomplete","page":"Utils","title":"JudiLing.iscomplete","text":"check a gram could complete a path\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#JudiLing.isstart","page":"Utils","title":"JudiLing.isstart","text":"check a gram could start a path\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#JudiLing.isnovel","page":"Utils","title":"JudiLing.isnovel","text":"check wheter a path is in training data or nor\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#JudiLing.check_used_token","page":"Utils","title":"JudiLing.check_used_token","text":"check whether there are token used in dataset\n\n\n\n\n\n","category":"function"},{"location":"man/utils/#JudiLing.cal_max_timestep","page":"Utils","title":"JudiLing.cal_max_timestep","text":"calculate max timestep given training and validation datasets\n\n\n\n\n\ncalculate max timestep given training dataset\n\n\n\n\n\n","category":"function"},{"location":"man/make_adjacency_matrix/","page":"Make Adjacency Matrix","title":"Make Adjacency Matrix","text":"CurrentModule = JudiLing","category":"page"},{"location":"man/make_adjacency_matrix/#Make-Adjacency-Matrix","page":"Make Adjacency Matrix","title":"Make Adjacency Matrix","text":"","category":"section"},{"location":"man/make_adjacency_matrix/","page":"Make Adjacency Matrix","title":"Make Adjacency Matrix","text":"  make_adjacency_matrix\n  make_adjacency_matrix(::Dict)","category":"page"},{"location":"man/make_adjacency_matrix/#JudiLing.make_adjacency_matrix","page":"Make Adjacency Matrix","title":"JudiLing.make_adjacency_matrix","text":"Make fulladjacency matrix\n\n\n\n\n\n","category":"function"},{"location":"man/make_adjacency_matrix/#JudiLing.make_adjacency_matrix-Tuple{Dict}","page":"Make Adjacency Matrix","title":"JudiLing.make_adjacency_matrix","text":"makeadjacencymatrix(::Dict) -> ::SparseMatrixCSC\n\nMake full adjacency matrix based only on the form of n-grams regardless whether  they are seen in the training data. This usually takes hours for large dataset.\n\n...\n\nArguments\n\ntokenized::Bool=false:if true, the dataset target is assumed tokenized\nsep_token::Union{Nothing, String, Char}=nothing: separate token\nverbose::Bool=false: if true, more information prints out\n\nExamples\n\ni2f = Dict([(1, \"#ab\"), (2, \"abc\"), (3, \"bc#\"), (4, \"#bc\"), (5, \"ab#\")])\nJudiLing.make_adjacency_matrix(i2f)\n\ni2f = Dict([(1, \"#-a-b\"), (2, \"a-b-c\"), (3, \"b-c-#\"), (4, \"#-b-c\"), (5, \"a-b-#\")])\nJudiLing.make_adjacency_matrix(\n  i2f,\n  tokenized=true,\n  sep_token=\"-\")\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/cholesky/","page":"Cholesky","title":"Cholesky","text":"CurrentModule = JudiLing","category":"page"},{"location":"man/cholesky/#Cholesky","page":"Cholesky","title":"Cholesky","text":"","category":"section"},{"location":"man/cholesky/","page":"Cholesky","title":"Cholesky","text":"  make_transform_fac\n  make_transform_matrix\n  make_transform_fac(::SparseMatrixCSC)\n  make_transform_fac(::Matrix)\n  make_transform_matrix(::Union{LinearAlgebra.Cholesky, SuiteSparse.CHOLMOD.Factor}, ::Union{SparseMatrixCSC, Matrix}, ::Union{SparseMatrixCSC, Matrix})\n  make_transform_matrix(::SparseMatrixCSC, ::Matrix)\n  make_transform_matrix(::Matrix, ::Union{SparseMatrixCSC, Matrix})\n  make_transform_matrix(::SparseMatrixCSC, ::SparseMatrixCSC)\n  format_matrix(::Union{SparseMatrixCSC, Matrix}, ::Symbol)","category":"page"},{"location":"man/cholesky/#JudiLing.make_transform_fac","page":"Cholesky","title":"JudiLing.make_transform_fac","text":"The first part of make transform matrix, usually in the learn_paths function to same time and computing resources.\n\n\n\n\n\n","category":"function"},{"location":"man/cholesky/#JudiLing.make_transform_matrix","page":"Cholesky","title":"JudiLing.make_transform_matrix","text":"Using cholesky decomposition to calculate transformation matrix from S to C or from C to S.\n\n\n\n\n\n","category":"function"},{"location":"man/cholesky/#JudiLing.make_transform_fac-Tuple{SparseArrays.SparseMatrixCSC}","page":"Cholesky","title":"JudiLing.make_transform_fac","text":"maketransformfac(::SparseMatrixCSC) -> ::SuiteSparse.CHOLMOD.Factor\n\nCalculate first part of cholesky decomposition for sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/cholesky/#JudiLing.make_transform_fac-Tuple{Array{T,2} where T}","page":"Cholesky","title":"JudiLing.make_transform_fac","text":"maketransformfac(::Matrix) -> ::LinearAlgebra.Cholesky\n\nCalculate first part of cholesky decomposition for dense matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/cholesky/#JudiLing.make_transform_matrix-Tuple{Union{SuiteSparse.CHOLMOD.Factor, LinearAlgebra.Cholesky},Union{Array{T,2} where T, SparseArrays.SparseMatrixCSC},Union{Array{T,2} where T, SparseArrays.SparseMatrixCSC}}","page":"Cholesky","title":"JudiLing.make_transform_matrix","text":"maketransformmatrix(::Union{LinearAlgebra.Cholesky, SuiteSparse.CHOLMOD.Factor}, ::Union{SparseMatrixCSC, Matrix}, ::Union{SparseMatrixCSC, Matrix}) -> ::Union{Matrix, SparseMatrixCSC}\n\nSecond part of calculate cholesky decomposition transformation matrix.\n\n...\n\nArguments\n\noutput_format::Symbol=:auto: to force output format to dense(:dense) or sparse(:sparse), make it auto(:auto) to determined by the program\nsparse_ratio::Float64=0.2: the ratio to decide whether a matrix is sparse\nverbose::Bool=false: if true, more information will be printed out\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/cholesky/#JudiLing.make_transform_matrix-Tuple{SparseArrays.SparseMatrixCSC,Array{T,2} where T}","page":"Cholesky","title":"JudiLing.make_transform_matrix","text":"maketransformmatrix(::SparseMatrixCSC, ::Matrix) -> ::Union{SparseMatrixCSC, Matrix}\n\nUsing cholesky decomposition to calculate transformation matrix from X to Y, where X is a sparse matrix and Y is a dense matrix.\n\n...\n\nArguments\n\nmethod::Symbol=:additive: shift mode whether :additive or :multiplicative\nshift::AbstractFloat=0.02: shift value\nmultiplier::AbstractFloat=1.01: multiplier value\noutput_format::Symbol=:auto: to force output format to dense(:dense) or sparse(:sparse), make it auto(:auto) to determined by the program\nsparse_ratio::Float64=0.2: the ratio to decide whether a matrix is sparse\nverbose::Bool=false: if true, more information will be printed out\n\nExamples\n\nJudiLing.make_transform_matrix(\n  C,\n  S,\n  method=:additive,\n  shift=0.02,\n  output_format=:auto,\n  sparse_ratio=0.2,\n  verbose=false)\n\nJudiLing.make_transform_matrix(\n  C,\n  S,\n  method=:multiplicative,\n  multiplier=1.01,\n  output_format=:auto,\n  sparse_ratio=0.2,\n  verbose=false)\n\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/cholesky/#JudiLing.make_transform_matrix-Tuple{Array{T,2} where T,Union{Array{T,2} where T, SparseArrays.SparseMatrixCSC}}","page":"Cholesky","title":"JudiLing.make_transform_matrix","text":"maketransformmatrix(::Matrix, ::Union{SparseMatrixCSC, Matrix}) -> ::Union{SparseMatrixCSC, Matrix}\n\nUsing cholesky decomposition to calculate transformation matrix from X to Y, where X is a dense matrix and Y is either a dense matrix or a sparse matrix.\n\n...\n\nArguments\n\nmethod::Symbol=:additive: shift mode whether :additive or :multiplicative\nshift::AbstractFloat=0.02: shift value\nmultiplier::AbstractFloat=1.01: multiplier value\noutput_format::Symbol=:auto: to force output format to dense(:dense) or sparse(:sparse), make it auto(:auto) to determined by the program\nsparse_ratio::Float64=0.2: the ratio to decide whether a matrix is sparse\nverbose::Bool=false: if true, more information will be printed out\n\nExamples\n\nJudiLing.make_transform_matrix(\n  C,\n  S,\n  method=:additive,\n  shift=0.02,\n  output_format=:auto,\n  sparse_ratio=0.2,\n  verbose=false)\n\nJudiLing.make_transform_matrix(\n  C,\n  S,\n  method=:multiplicative,\n  multiplier=1.01,\n  output_format=:auto,\n  sparse_ratio=0.2,\n  verbose=false)\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/cholesky/#JudiLing.make_transform_matrix-Tuple{SparseArrays.SparseMatrixCSC,SparseArrays.SparseMatrixCSC}","page":"Cholesky","title":"JudiLing.make_transform_matrix","text":"maketransformmatrix(::SparseMatrixCSC, ::SparseMatrixCSC) -> ::Union{SparseMatrixCSC, Matrix}\n\nUsing cholesky decomposition to calculate transformation matrix from X to Y, where X is a sparse matrix and Y is a sparse matrix.\n\n...\n\nArguments\n\nmethod::Symbol=:additive: shift mode whether :additive or :multiplicative\nshift::AbstractFloat=0.02: shift value\nmultiplier::AbstractFloat=1.01: multiplier value\noutput_format::Symbol=:auto: to force output format to dense(:dense) or sparse(:sparse), make it auto(:auto) to determined by the program\nsparse_ratio::Float64=0.2: the ratio to decide whether a matrix is sparse\nverbose::Bool=false: if true, more information will be printed out\n\nExamples\n\nJudiLing.make_transform_matrix(\n  C,\n  S,\n  method=:additive,\n  shift=0.02,\n  output_format=:auto,\n  sparse_ratio=0.2,\n  verbose=false)\n\nJudiLing.make_transform_matrix(\n  C,\n  S,\n  method=:multiplicative,\n  multiplier=1.01,\n  output_format=:auto,\n  sparse_ratio=0.2,\n  verbose=false)\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/cholesky/#JudiLing.format_matrix-Tuple{Union{Array{T,2} where T, SparseArrays.SparseMatrixCSC},Symbol}","page":"Cholesky","title":"JudiLing.format_matrix","text":"format_matrix(::Union{SparseMatrixCSC, Matrix}, ::Symbol) -> ::Union{SparseMatrixCSC, Matrix}\n\nConvert output matrix format to either a dense matrix or a sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/make_semantic_matrix/","page":"Make Semantic Matrix","title":"Make Semantic Matrix","text":"CurrentModule = JudiLing","category":"page"},{"location":"man/make_semantic_matrix/#Make-Semantic-Matrix","page":"Make Semantic Matrix","title":"Make Semantic Matrix","text":"","category":"section"},{"location":"man/make_semantic_matrix/","page":"Make Semantic Matrix","title":"Make Semantic Matrix","text":"  PS_Matrix_Struct\n  make_pS_matrix\n  make_S_matrix\n  make_pS_matrix(::DataFrame)\n  make_pS_matrix(::DataFrame, ::PS_Matrix_Struct)\n  make_S_matrix(::DataFrame, ::Vector, ::Vector)\n  make_S_matrix(::DataFrame, ::DataFrame, ::Vector, ::Vector)\n  make_S_matrix(::DataFrame, ::Vector)\n  make_S_matrix(::DataFrame, ::DataFrame, ::Vector)","category":"page"},{"location":"man/make_semantic_matrix/#JudiLing.PS_Matrix_Struct","page":"Make Semantic Matrix","title":"JudiLing.PS_Matrix_Struct","text":"This a structure that store all information about prelinguistic and their feature indices. pS is the cue matrix f2i is the dictionary return indices giving features i2f is in another hand return features when giving indices\n\n\n\n\n\n","category":"type"},{"location":"man/make_semantic_matrix/#JudiLing.make_pS_matrix","page":"Make Semantic Matrix","title":"JudiLing.make_pS_matrix","text":"Make prelinguistic semantic matrix.\n\n\n\n\n\n","category":"function"},{"location":"man/make_semantic_matrix/#JudiLing.make_S_matrix","page":"Make Semantic Matrix","title":"JudiLing.make_S_matrix","text":"Make simulated semantic matrix.\n\n\n\n\n\n","category":"function"},{"location":"man/make_semantic_matrix/#JudiLing.make_pS_matrix-Tuple{DataFrames.DataFrame}","page":"Make Semantic Matrix","title":"JudiLing.make_pS_matrix","text":"makepSmatrix(::DataFrame) -> ::PSMatrixStruct\n\nCreate prelinguistic matrix given a csv file.\n\n...\n\nArguments\n\nfeatures_col::Symbol=:CommunicativeIntention: the column name for target\nsep_token::String=\"_\": the seperated token\n\nExamples\n\ns_obj_train = JudiLing.make_pS_matrix(\n  utterance,\n  features_col=:CommunicativeIntention,\n  sep_token=\"_\")\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/make_semantic_matrix/#JudiLing.make_pS_matrix-Tuple{DataFrames.DataFrame,JudiLing.PS_Matrix_Struct}","page":"Make Semantic Matrix","title":"JudiLing.make_pS_matrix","text":"makepSmatrix(::DataFrame, PSMatrixStruct) -> ::PSMatrixStruct\n\nConstruct prelinguistic matrix giving utterances and training sobj. The feature indices should maintain the same as thoes in sobj.\n\n...\n\nArguments\n\nfeatures_col::Symbol=:CommunicativeIntention: the column name for target\nsep_token::String=\"_\": the seperated token\n\nExamples\n\ns_obj_val = JudiLing.make_pS_matrix(\n  utterance_val,\n  s_obj_train,\n  features_col=:CommunicativeIntention,\n  sep_token=\"_\")\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/make_semantic_matrix/#JudiLing.make_S_matrix-Tuple{DataFrames.DataFrame,Array{T,1} where T,Array{T,1} where T}","page":"Make Semantic Matrix","title":"JudiLing.make_S_matrix","text":"makeSmatrix(::DataFrame, ::Vector, ::Vector) -> ::Matrix\n\nCreate simulated semantic matrix. Give each feature a random semantic vector,  and sum up all features to compose the semantic vector.\n\n...\n\nArguments\n\nncol::Int64=200: the dimension size of vectors, usually the same as cue vectors\nsd_base_mean::Int64=1: the sd mean of base features\nsd_inflection_mean::Int64=1: the sd mean of inflectional features\nsd_base::Int64=4: the sd of base features\nsd_inflection::Int64=4: the sd of inflectional features\nseed::Int64=314: the random seed\nisdeep::Bool=true: if true, mean of each feature is also randomized \nadd_noise::Bool=true: if true, add noise at the end of construction\nsd_noise::Int64=1: the sd of the noise matrix\nnormalized::Bool=false: if true, most of the values range between 1 and -1, it may exceeds 1 or -1 depending on the sd\n\nExamples\n\n# Examples\nS_train = JudiLing.make_S_matrix(\n  french,\n  [\"Lexeme\"],\n  [\"Tense\",\"Aspect\",\"Person\",\"Number\",\"Gender\",\"Class\",\"Mood\"],\n  ncol=200,\n  sd_base_mean=1,\n  sd_inflection_mean=1,\n  sd_base=4,\n  sd_inflection=4,\n  isdeep=true,\n  add_noise=true,\n  sd_noise=1,\n  normalized=false)\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/make_semantic_matrix/#JudiLing.make_S_matrix-Tuple{DataFrames.DataFrame,DataFrames.DataFrame,Array{T,1} where T,Array{T,1} where T}","page":"Make Semantic Matrix","title":"JudiLing.make_S_matrix","text":"makeSmatrix(::DataFrame, ::DataFrame, ::Vector, ::Vector) -> ::Tuple{Matrix, Matrix}\n\nCreate validation simulated semantic matrix. Give each feature a random  semantic vector, and sum up all features to compose the semantic vector.\n\n...\n\nArguments\n\nncol::Int64=200: the dimension size of vectors, usually the same as cue vectors\nsd_base_mean::Int64=1: the sd mean of base features\nsd_inflection_mean::Int64=1: the sd mean of inflectional features\nsd_base::Int64=4: the sd of base features\nsd_inflection::Int64=4: the sd of inflectional features\nseed::Int64=314: the random seed\nisdeep::Bool=true: if true, mean of each feature is also randomized \nadd_noise::Bool=true: if true, add noise at the end of construction\nsd_noise::Int64=1: the sd of the noise matrix\nnormalized::Bool=false: if true, most of the values range between 1 and -1, it may exceeds 1 or -1 depending on the sd\n\nExamples\n\n# Examples\nS_train, S_val = JudiLing.make_S_matrix(\n  french,\n  french_val,\n  [\"Lexeme\"],\n  [\"Tense\",\"Aspect\",\"Person\",\"Number\",\"Gender\",\"Class\",\"Mood\"],\n  ncol=200,\n  sd_base_mean=1,\n  sd_inflection_mean=1,\n  sd_base=4,\n  sd_inflection=4,\n  isdeep=true,\n  add_noise=true,\n  sd_noise=1,\n  normalized=false)\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/make_semantic_matrix/#JudiLing.make_S_matrix-Tuple{DataFrames.DataFrame,Array{T,1} where T}","page":"Make Semantic Matrix","title":"JudiLing.make_S_matrix","text":"makeSmatrix(::DataFrame, ::Vector) -> ::Matrix\n\nCreate simulated semantic matrix, provided for dataset that only have base  features. Give each feature a random semantic vector, and sum up all features  to compose the semantic vector.\n\n...\n\nArguments\n\nncol::Int64=200: the dimension size of vectors, usually the same as cue vectors\nsd_base_mean::Int64=1: the sd mean of base features\nsd_base::Int64=4: the sd of base features\nseed::Int64=314: the random seed\nisdeep::Bool=true: if true, mean of each feature is also randomized \nadd_noise::Bool=true: if true, add noise at the end of construction\nsd_noise::Int64=1: the sd of the noise matrix\nnormalized::Bool=false: if true, most of the values range between 1 and -1, it may exceeds 1 or -1 depending on the sd\n\nExamples\n\nS_train = JudiLing.make_S_matrix(\n  french,\n  [\"Lexeme\"],\n  ncol=200,\n  sd_base_mean=1,\n  sd_base=4,\n  isdeep=true,\n  add_noise=true,\n  sd_noise=1,\n  normalized=false)\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/make_semantic_matrix/#JudiLing.make_S_matrix-Tuple{DataFrames.DataFrame,DataFrames.DataFrame,Array{T,1} where T}","page":"Make Semantic Matrix","title":"JudiLing.make_S_matrix","text":"makeSmatrix(::DataFrame, ::DataFrame, ::Vector) -> ::Tuple{Matrix, Matrix}\n\nCreate validation simulated semantic matrix, provided for dataset that only  have base features. Give each feature a random semantic vector, and sum up all  features to compose the semantic vector.\n\n...\n\nArguments\n\nncol::Int64=200: the dimension size of vectors, usually the same as cue vectors\nsd_base_mean::Int64=1: the sd mean of base features\nsd_base::Int64=4: the sd of base features\nseed::Int64=314: the random seed\nisdeep::Bool=true: if true, mean of each feature is also randomized \nadd_noise::Bool=true: if true, add noise at the end of construction\nsd_noise::Int64=1: the sd of the noise matrix\nnormalized::Bool=false: if true, most of the values range between 1 and -1, it may exceeds 1 or -1 depending on the sd\n\nExamples\n\nS_train, S_val = JudiLing.make_S_matrix(\n  french,\n  french_val,\n  [\"Lexeme\"],\n  ncol=200,\n  sd_base_mean=1,\n  sd_base=4,\n  isdeep=true,\n  add_noise=true,\n  sd_noise=1,\n  normalized=false)\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/eval/","page":"Evaluation","title":"Evaluation","text":"CurrentModule = JudiLing","category":"page"},{"location":"man/eval/#Find-Paths","page":"Evaluation","title":"Find Paths","text":"","category":"section"},{"location":"man/eval/","page":"Evaluation","title":"Evaluation","text":"  Comp_Acc_Struct\n  accuracy_comprehension\n  eval_SC\n  eval_acc(::Array, ::Array)\n  eval_acc_loose(::Array, ::Array)\n  eval_gpi\n  eval_manual","category":"page"},{"location":"man/eval/#JudiLing.Comp_Acc_Struct","page":"Evaluation","title":"JudiLing.Comp_Acc_Struct","text":"A structure that stores info about comprehension accuracy.\n\n\n\n\n\n","category":"type"},{"location":"man/eval/#JudiLing.accuracy_comprehension","page":"Evaluation","title":"JudiLing.accuracy_comprehension","text":"accuracycomprehension(::Matrix, ::Matrix) -> ::CompAcc_Struct\n\nEvaluate the comprehension accuracy.\n\n...\n\nArguments\n\ntarget_col::Union{String, Symbol}=:Words: target column name\nbase::Vector=[\"Lexeme\"]: base features\ninflections::Union{Nothing, Vector}=nothing: inflective features\n\nExamples\n\naccuracy_comprehension(\n  S_train,\n  Shat_train,\n  latin_val,\n  target_col=:Words,\n  base=[\"Lexeme\"],\n  inflections=[\"Person\",\"Number\",\"Tense\",\"Voice\",\"Mood\"]\n  )\n\naccuracy_comprehension(\n  S_val,\n  Shat_val,\n  latin_train,\n  target_col=:Words,\n  base=[\"Lexeme\"],\n  inflections=[\"Person\",\"Number\",\"Tense\",\"Voice\",\"Mood\"]\n  )\n\n...\n\n\n\n\n\n","category":"function"},{"location":"man/eval/#JudiLing.eval_SC","page":"Evaluation","title":"JudiLing.eval_SC","text":"eval_SC(Union{SparseMatrixCSC, Matrix}, Union{SparseMatrixCSC, Matrix}) -> ::Float64\n\nEvaluate the accuracy of S and Shat or C and Chat.\n\n...\n\nExamples\n\n#after you had Shat and Chat\neval_SC(cue_obj_train.C, Chat_train)\neval_SC(cue_obj_val.C, Chat_val)\neval_SC(S_train, Shat_train)\neval_SC(S_val, Shat_val)\n\n...\n\n\n\n\n\n","category":"function"},{"location":"man/eval/#JudiLing.eval_acc-Tuple{Array,Array}","page":"Evaluation","title":"JudiLing.eval_acc","text":"eval_acc(::Array, ::Array) -> ::Float64\n\nEvaluate the accuracy of the results from learnpaths() or buildpaths().\n\n...\n\nArguments\n\nverbose::Bool=false: if true, more information will be printed out\n\nExamples\n\n#after you had results from learn_paths or build_paths\nacc_train = JudiLing.eval_acc(\n  res_train,\n  cue_obj_train.gold_ind,\n  verbose=false\n)\nacc_val = JudiLing.eval_acc(\n  res_val,\n  cue_obj_val.gold_ind,\n  verbose=false\n)\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/eval/#JudiLing.eval_acc_loose-Tuple{Array,Array}","page":"Evaluation","title":"JudiLing.eval_acc_loose","text":"evalaccloose(::Array, ::Array) -> ::Float64\n\nEvaluate the accuracy of the results from learnpaths() or buildpaths(), if  one of the candidates is correct, then we take it as correct. This reflects how  many paths were found but could not be recognised as the best path.\n\n...\n\nArguments\n\nverbose::Bool=false: if true, more information will be printed out\n\nExamples\n\n#after you had results from learn_paths or build_paths\nacc_train_loose = JudiLing.eval_acc_loose(\n  res_train,\n  cue_obj_train.gold_ind,\n  verbose=false\n)\nacc_val_loose = JudiLing.eval_acc_loose(\n  res_val,\n  cue_obj_val.gold_ind,\n  verbose=false\n)\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/eval/#JudiLing.eval_gpi","page":"Evaluation","title":"JudiLing.eval_gpi","text":"evalgpi(::Vector{GoldPathInfoStruct}, ::Float64, ::Float64) -> ::Array Evaluate gold path info\n\n\n\n\n\n","category":"function"},{"location":"man/eval/#JudiLing.eval_manual","page":"Evaluation","title":"JudiLing.eval_manual","text":"eval_manual(::Array, ::DataFrame, ::Dict) -> ::Nothing\n\nCheck the results manually.\n\n\n\n\n\n","category":"function"},{"location":"man/find_path/","page":"Find Paths","title":"Find Paths","text":"CurrentModule = JudiLing","category":"page"},{"location":"man/find_path/#Find-Paths","page":"Find Paths","title":"Find Paths","text":"","category":"section"},{"location":"man/find_path/","page":"Find Paths","title":"Find Paths","text":"  Result_Path_Info_Struct\n  Gold_Path_Info_Struct\n  learn_paths\n  build_paths\n  learn_paths(::DataFrame,::DataFrame,::SparseMatrixCSC,::Union{SparseMatrixCSC, Matrix},::Union{SparseMatrixCSC, Matrix},::Matrix,::SparseMatrixCSC,::Dict)\n  build_paths(::DataFrame,::SparseMatrixCSC,::Union{SparseMatrixCSC, Matrix},::Union{SparseMatrixCSC, Matrix},::Matrix,::SparseMatrixCSC,::Dict,::Array)\n  eval_can(::Vector{Vector{Tuple{Vector{Int64}, Int64}}},::Union{SparseMatrixCSC, Matrix},::Union{SparseMatrixCSC, Matrix},::Dict,::Int64,::Bool)\n  find_top_feature_indices(::Matrix, ::Array)","category":"page"},{"location":"man/find_path/#JudiLing.Result_Path_Info_Struct","page":"Find Paths","title":"JudiLing.Result_Path_Info_Struct","text":"Store path information found by learnpaths() or buildpaths()\n\n\n\n\n\n","category":"type"},{"location":"man/find_path/#JudiLing.Gold_Path_Info_Struct","page":"Find Paths","title":"JudiLing.Gold_Path_Info_Struct","text":"Store gold path information including indices and indices' support and total  support. It can be used to evaluate how low the threshold needs to be set in  order to find the correct paths.\n\n\n\n\n\n","category":"type"},{"location":"man/find_path/#JudiLing.learn_paths","page":"Find Paths","title":"JudiLing.learn_paths","text":"learnpaths(::DataFrame,::DataFrame,::SparseMatrixCSC,::Union{SparseMatrixCSC, Matrix},::Union{SparseMatrixCSC, Matrix},::Matrix,::SparseMatrixCSC,::Dict) -> ::::Union{Tuple{Vector{Vector{ResultPathInfoStruct}}, Vector{GoldPathInfoStruct}}, Vector{Vector{ResultPathInfoStruct}}}\n\nTake individual timestep and calculate its corresponding Yt_hat.\n\n...\n\nArguments\n\ngold_ind::Union{Nothing, Vector}=nothing: for in goldpathinfo mode\nShat_val::Union{Nothing, Matrix}=nothing: for goldpathinfo mode\ncheck_gold_path::Bool=false: if true, turn on goldpathinfo mode\nmax_t::Int64=15: maximum timestep\nmax_can::Int64=10: maximum candidates to keep in the results\nthreshold::AbstractFloat=0.1:the value set for the support such that if the support of a n-gram is higher than this value, select the n-gram anyway\nis_tolerant::Bool=false: if true, select a specified number of n-grams whose supports are below threshold and above tolerance to be added to the path\ntolerance::AbstractFloat=(-1000.0): the value set in tolerant mode such that if the support for a n-gram is inbetween this value and the threshold and the max_tolerance number has not been reached, then allow this n-gram to be added to the path\nmax_tolerance::Int64=4: maximum number of nodes allowed in a path\ngrams::Int64=3: the number of grams for cues\ntokenized::Bool=false: if true, the dataset target is assumed to be tokenized\nsep_token::Union{Nothing, String, Char}=nothing: separate token\nkeep_sep::Bool=false:if true, keep separators in results as well\ntarget_col::Union{String, :Symbol}=:Words: target column names\nissparse::Symbol=:auto: Mt matrix output format mode\nsparse_ratio::Float64=0.2: the ratio to decide whether a matrix is sparse\nverbose::Bool=false: if true, more information will be printed out\n\nExamples\n\nres_train, gpi_train = JudiLing.learn_paths(\n  latin_train,\n  latin_train,\n  cue_obj_train.C,\n  S_train,\n  F_train,\n  Chat_train,\n  A,\n  cue_obj_train.i2f,\n  gold_ind=cue_obj_train.gold_ind,\n  Shat_val=Shat_train,\n  check_gold_path=true,\n  max_t=max_t,\n  max_can=10,\n  grams=3,\n  threshold=0.1,\n  tokenized=false,\n  sep_token=\"_\",\n  keep_sep=false,\n  target_col=:Word,\n  issparse=:dense,\n  verbose=false)\n\nres_val, gpi_val = JudiLing.learn_paths(\n  latin_train,\n  latin_val,\n  cue_obj_train.C,\n  S_val,\n  F_train,\n  Chat_val,\n  A,\n  cue_obj_train.i2f,\n  gold_ind=cue_obj_val.gold_ind,\n  Shat_val=Shat_val,\n  check_gold_path=true,\n  max_t=max_t,\n  max_can=10,\n  grams=3,\n  threshold=0.1,\n  is_tolerant=true,\n  tolerance=0.1,\n  max_tolerance=0,\n  tokenized=false,\n  sep_token=\"-\",\n  keep_sep=false,\n  target_col=:Word,\n  issparse=:dense,\n  verbose=false)\n\n...\n\n\n\n\n\n","category":"function"},{"location":"man/find_path/#JudiLing.build_paths","page":"Find Paths","title":"JudiLing.build_paths","text":"buildpaths(::DataFrame,::SparseMatrixCSC,::Union{SparseMatrixCSC, Matrix},::Union{SparseMatrixCSC, Matrix},::Matrix,::SparseMatrixCSC,::Dict,::Array) -> ::Vector{Vector{ResultPathInfoStruct}}\n\nbuild_paths function is a shortcut algorithm for finding paths that only takes the n-grams of that which are close to the targets.\n\n...\n\nArguments\n\nrC::Union{Nothing, Matrix}=nothing: correlation Matrix of C and Chat, pass it to save computing time\nmax_t::Int64=15: maximum timestep\nmax_can::Int64=10: maximum candidates to keep in the results\nn_neighbors::Int64=10: find indices only in top n neighbors\ngrams::Int64=3: the number of grams for cues\ntokenized::Bool=false: if true, the dataset target is assumed to be tokenized\nsep_token::Union{Nothing, String, Char}=nothing: separate token\ntarget_col::Union{String, :Symbol}=:Words: target column names\nverbose::Bool=false: if true, more information will be printed out\n\nExamples\n\nJudiLing.build_paths(\n  latin_train,\n  cue_obj_train.C,\n  S_train,\n  F_train,\n  Chat_train,\n  A,\n  cue_obj_train.i2f,\n  cue_obj_train.gold_ind,\n  max_t=max_t,\n  n_neighbors=10,\n  verbose=false\n  )\n\nJudiLing.build_paths(\n  latin_val,\n  cue_obj_train.C,\n  S_val,\n  F_train,\n  Chat_val,\n  A,\n  cue_obj_train.i2f,\n  cue_obj_train.gold_ind,\n  max_t=max_t,\n  n_neighbors=10,\n  verbose=false\n  )\n\n...\n\n\n\n\n\n","category":"function"},{"location":"man/find_path/#JudiLing.learn_paths-Tuple{DataFrames.DataFrame,DataFrames.DataFrame,SparseArrays.SparseMatrixCSC,Union{Array{T,2} where T, SparseArrays.SparseMatrixCSC},Union{Array{T,2} where T, SparseArrays.SparseMatrixCSC},Array{T,2} where T,SparseArrays.SparseMatrixCSC,Dict}","page":"Find Paths","title":"JudiLing.learn_paths","text":"learnpaths(::DataFrame,::DataFrame,::SparseMatrixCSC,::Union{SparseMatrixCSC, Matrix},::Union{SparseMatrixCSC, Matrix},::Matrix,::SparseMatrixCSC,::Dict) -> ::::Union{Tuple{Vector{Vector{ResultPathInfoStruct}}, Vector{GoldPathInfoStruct}}, Vector{Vector{ResultPathInfoStruct}}}\n\nTake individual timestep and calculate its corresponding Yt_hat.\n\n...\n\nArguments\n\ngold_ind::Union{Nothing, Vector}=nothing: for in goldpathinfo mode\nShat_val::Union{Nothing, Matrix}=nothing: for goldpathinfo mode\ncheck_gold_path::Bool=false: if true, turn on goldpathinfo mode\nmax_t::Int64=15: maximum timestep\nmax_can::Int64=10: maximum candidates to keep in the results\nthreshold::AbstractFloat=0.1:the value set for the support such that if the support of a n-gram is higher than this value, select the n-gram anyway\nis_tolerant::Bool=false: if true, select a specified number of n-grams whose supports are below threshold and above tolerance to be added to the path\ntolerance::AbstractFloat=(-1000.0): the value set in tolerant mode such that if the support for a n-gram is inbetween this value and the threshold and the max_tolerance number has not been reached, then allow this n-gram to be added to the path\nmax_tolerance::Int64=4: maximum number of nodes allowed in a path\ngrams::Int64=3: the number of grams for cues\ntokenized::Bool=false: if true, the dataset target is assumed to be tokenized\nsep_token::Union{Nothing, String, Char}=nothing: separate token\nkeep_sep::Bool=false:if true, keep separators in results as well\ntarget_col::Union{String, :Symbol}=:Words: target column names\nissparse::Symbol=:auto: Mt matrix output format mode\nsparse_ratio::Float64=0.2: the ratio to decide whether a matrix is sparse\nverbose::Bool=false: if true, more information will be printed out\n\nExamples\n\nres_train, gpi_train = JudiLing.learn_paths(\n  latin_train,\n  latin_train,\n  cue_obj_train.C,\n  S_train,\n  F_train,\n  Chat_train,\n  A,\n  cue_obj_train.i2f,\n  gold_ind=cue_obj_train.gold_ind,\n  Shat_val=Shat_train,\n  check_gold_path=true,\n  max_t=max_t,\n  max_can=10,\n  grams=3,\n  threshold=0.1,\n  tokenized=false,\n  sep_token=\"_\",\n  keep_sep=false,\n  target_col=:Word,\n  issparse=:dense,\n  verbose=false)\n\nres_val, gpi_val = JudiLing.learn_paths(\n  latin_train,\n  latin_val,\n  cue_obj_train.C,\n  S_val,\n  F_train,\n  Chat_val,\n  A,\n  cue_obj_train.i2f,\n  gold_ind=cue_obj_val.gold_ind,\n  Shat_val=Shat_val,\n  check_gold_path=true,\n  max_t=max_t,\n  max_can=10,\n  grams=3,\n  threshold=0.1,\n  is_tolerant=true,\n  tolerance=0.1,\n  max_tolerance=0,\n  tokenized=false,\n  sep_token=\"-\",\n  keep_sep=false,\n  target_col=:Word,\n  issparse=:dense,\n  verbose=false)\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/find_path/#JudiLing.build_paths-Tuple{DataFrames.DataFrame,SparseArrays.SparseMatrixCSC,Union{Array{T,2} where T, SparseArrays.SparseMatrixCSC},Union{Array{T,2} where T, SparseArrays.SparseMatrixCSC},Array{T,2} where T,SparseArrays.SparseMatrixCSC,Dict,Array}","page":"Find Paths","title":"JudiLing.build_paths","text":"buildpaths(::DataFrame,::SparseMatrixCSC,::Union{SparseMatrixCSC, Matrix},::Union{SparseMatrixCSC, Matrix},::Matrix,::SparseMatrixCSC,::Dict,::Array) -> ::Vector{Vector{ResultPathInfoStruct}}\n\nbuild_paths function is a shortcut algorithm for finding paths that only takes the n-grams of that which are close to the targets.\n\n...\n\nArguments\n\nrC::Union{Nothing, Matrix}=nothing: correlation Matrix of C and Chat, pass it to save computing time\nmax_t::Int64=15: maximum timestep\nmax_can::Int64=10: maximum candidates to keep in the results\nn_neighbors::Int64=10: find indices only in top n neighbors\ngrams::Int64=3: the number of grams for cues\ntokenized::Bool=false: if true, the dataset target is assumed to be tokenized\nsep_token::Union{Nothing, String, Char}=nothing: separate token\ntarget_col::Union{String, :Symbol}=:Words: target column names\nverbose::Bool=false: if true, more information will be printed out\n\nExamples\n\nJudiLing.build_paths(\n  latin_train,\n  cue_obj_train.C,\n  S_train,\n  F_train,\n  Chat_train,\n  A,\n  cue_obj_train.i2f,\n  cue_obj_train.gold_ind,\n  max_t=max_t,\n  n_neighbors=10,\n  verbose=false\n  )\n\nJudiLing.build_paths(\n  latin_val,\n  cue_obj_train.C,\n  S_val,\n  F_train,\n  Chat_val,\n  A,\n  cue_obj_train.i2f,\n  cue_obj_train.gold_ind,\n  max_t=max_t,\n  n_neighbors=10,\n  verbose=false\n  )\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/find_path/#JudiLing.eval_can-Tuple{Array{Array{Tuple{Array{Int64,1},Int64},1},1},Union{Array{T,2} where T, SparseArrays.SparseMatrixCSC},Union{Array{T,2} where T, SparseArrays.SparseMatrixCSC},Dict,Int64,Bool}","page":"Find Paths","title":"JudiLing.eval_can","text":"evalcan(::Vector{Vector{Tuple{Vector{Int64}, Int64}}},::Union{SparseMatrixCSC, Matrix},::Union{SparseMatrixCSC, Matrix},::Dict,::Int64,::Bool) -> ::Array{Array{ResultPathInfoStruct,1},1}\n\nEvaluate each candidate with regard to its predicted semantic vector.\n\n\n\n\n\n","category":"method"},{"location":"man/find_path/#JudiLing.find_top_feature_indices-Tuple{Array{T,2} where T,Array}","page":"Find Paths","title":"JudiLing.find_top_feature_indices","text":"findtopfeature_indices(::Matrix, ::Array) -> ::Vector{Vector{Int64}}\n\nFind all indices of the top n closest neighbors for a given target.\n\n\n\n\n\n","category":"method"},{"location":"man/all_manual/","page":"All Manual index","title":"All Manual index","text":"CurrentModule = JudiLing","category":"page"},{"location":"man/all_manual/","page":"All Manual index","title":"All Manual index","text":"","category":"page"},{"location":"man/output/","page":"Output","title":"Output","text":"CurrentModule = JudiLing","category":"page"},{"location":"man/output/#Output","page":"Output","title":"Output","text":"","category":"section"},{"location":"man/output/","page":"Output","title":"Output","text":"  write2csv\n  write2df\n  write2csv(::Array{Array{Result_Path_Info_Struct,1},1}, ::DataFrame, ::Cue_Matrix_Struct, ::Cue_Matrix_Struct, ::String)\n  write2csv(::Vector{Gold_Path_Info_Struct}, ::String)\n  write2df(::Array{Array{Result_Path_Info_Struct,1},1}, ::DataFrame, ::Cue_Matrix_Struct, ::Cue_Matrix_Struct)","category":"page"},{"location":"man/output/#JudiLing.write2csv","page":"Output","title":"JudiLing.write2csv","text":"write results into csv file, support for path results and gold path information\n\n\n\n\n\n","category":"function"},{"location":"man/output/#JudiLing.write2df","page":"Output","title":"JudiLing.write2df","text":"create a datafrate with results\n\n\n\n\n\n","category":"function"},{"location":"man/output/#JudiLing.write2csv-Tuple{Array{Array{JudiLing.Result_Path_Info_Struct,1},1},DataFrames.DataFrame,JudiLing.Cue_Matrix_Struct,JudiLing.Cue_Matrix_Struct,String}","page":"Output","title":"JudiLing.write2csv","text":"write2csv(::Array{Array{ResultPathInfoStruct,1},1}, ::DataFrame, ::CueMatrixStruct, ::CueMatrix_Struct, ::String)\n\nwrite results into csv file, support for path results\n\n...\n\nArguments\n\ngrams::Int64=3: the number of grams for cues \ntokenized::Bool=false: whether the target is tokenized\nsep_token::Union{Nothing, String, Char}=nothing: what is the separate token\nstart_end_token::Union{String, Char}=\"#\": token at beginning and ending token\noutput_sep_token::Union{String, Char}=\"\": output separate token\npath_sep_token::Union{String, Char}=\":\": token glued path nodes together\ntarget_col::Union{String, Symbol}=:Words: the column name for target\nroot_dir::String=\".\": dir path for package root dir\noutput_dir::String=\".\": output dir inside root dir\n\nExamples\n\n#after you had results from learn_paths or build_paths\nJudiLing.write2csv(\n  res_train,\n  latin_train,\n  cue_obj_train,\n  cue_obj_train,\n  \"res_latin_train.csv\",\n  grams=3,\n  tokenized=false,\n  sep_token=nothing,\n  start_end_token=\"#\",\n  output_sep_token=\"\",\n  path_sep_token=\":\",\n  target_col=:Word,\n  root_dir=\".\",\n  output_dir=\"test_out\")\n\nJudiLing.write2csv(\n  res_val,\n  latin_val,\n  cue_obj_train,\n  cue_obj_val,\n  \"res_latin_val.csv\",\n  grams=3,\n  tokenized=false,\n  sep_token=nothing,\n  start_end_token=\"#\",\n  output_sep_token=\"\",\n  path_sep_token=\":\",\n  target_col=:Word,\n  root_dir=\".\",\n  output_dir=\"test_out\")\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/output/#JudiLing.write2csv-Tuple{Array{JudiLing.Gold_Path_Info_Struct,1},String}","page":"Output","title":"JudiLing.write2csv","text":"write2csv(::Vector{GoldPathInfo_Struct}, ::String)\n\nwrite gold path information into csv file\n\n...\n\nArguments\n\nroot_dir::String=\".\": dir path for package root dir\noutput_dir::String=\".\": output dir inside root dir\n\nExamples\n\n#after you had results from learn_paths or build_paths\nJudiLing.write2csv(\n  gpi_train,\n  \"gpi_latin_train.csv\",\n  root_dir=\".\",\n  output_dir=\"test_out\"\n  )\n\nJudiLing.write2csv(\n  gpi_val,\n  \"gpi_latin_val.csv\",\n  root_dir=\".\",\n  output_dir=\"test_out\"\n  )\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/output/#JudiLing.write2df-Tuple{Array{Array{JudiLing.Result_Path_Info_Struct,1},1},DataFrames.DataFrame,JudiLing.Cue_Matrix_Struct,JudiLing.Cue_Matrix_Struct}","page":"Output","title":"JudiLing.write2df","text":"write2df(::Array{Array{ResultPathInfoStruct,1},1}, ::DataFrame, ::CueMatrixStruct, ::CueMatrix_Struct)\n\nwrite results into dataframe, support for path results\n\n...\n\nArguments\n\ngrams::Int64=3: the number of grams for cues \ntokenized::Bool=false: whether the target is tokenized\nsep_token::Union{Nothing, String, Char}=nothing: what is the separate token\nstart_end_token::Union{String, Char}=\"#\": token at beginning and ending token\noutput_sep_token::Union{String, Char}=\"\": output separate token\npath_sep_token::Union{String, Char}=\":\": token glued path nodes together\ntarget_col::Union{String, Symbol}=:Words: the column name for target\n\nExamples\n\n#after you had results from learn_paths or build_paths\nJudiLing.write2df(\n  res_train,\n  latin_train,\n  cue_obj_train,\n  cue_obj_train,\n  grams=3,\n  tokenized=false,\n  sep_token=nothing,\n  start_end_token=\"#\",\n  output_sep_token=\"\",\n  path_sep_token=\":\",\n  target_col=:Word)\n\nJudiLing.write2df(\n  res_val,\n  latin_val,\n  cue_obj_train,\n  cue_obj_val,\n  grams=3,\n  tokenized=false,\n  sep_token=nothing,\n  start_end_token=\"#\",\n  output_sep_token=\"\",\n  path_sep_token=\":\",\n  target_col=:Word)\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/make_yt_matrix/","page":"Make Yt Matrix","title":"Make Yt Matrix","text":"CurrentModule = JudiLing","category":"page"},{"location":"man/make_yt_matrix/#Make-Yt-Matrix","page":"Make Yt Matrix","title":"Make Yt Matrix","text":"","category":"section"},{"location":"man/make_yt_matrix/","page":"Make Yt Matrix","title":"Make Yt Matrix","text":"  make_Yt_matrix\n  make_Yt_matrix(::Int64, ::DataFrame)","category":"page"},{"location":"man/make_yt_matrix/#JudiLing.make_Yt_matrix","page":"Make Yt Matrix","title":"JudiLing.make_Yt_matrix","text":"make Y matrix given timestep t\n\n\n\n\n\n","category":"function"},{"location":"man/make_yt_matrix/#JudiLing.make_Yt_matrix-Tuple{Int64,DataFrames.DataFrame}","page":"Make Yt Matrix","title":"JudiLing.make_Yt_matrix","text":"makeYtmatrix(::Int64, ::DataFrame)\n\nMake full adjacency matrix based only on the form of n-grams regardless whether  they are seen in the training data. This usually takes hours for large dataset.\n\n...\n\nArguments\n\ntokenized::Bool=false: whether n-grams are tokenized\nsep_token::Union{Nothing, String, Char}=nothing: what is the sepertate token\nverbose::Bool=false: if verbose, more information prints out\n\nExamples\n\nlatin = CSV.DataFrame!(CSV.File(joinpath(\"data\", \"latin_mini.csv\")))\nJudiLing.make_Yt_matrix(2, latin)\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/test_combo/","page":"Test Combo","title":"Test Combo","text":"CurrentModule = JudiLing","category":"page"},{"location":"man/test_combo/#Test-Combo","page":"Test Combo","title":"Test Combo","text":"","category":"section"},{"location":"man/test_combo/","page":"Test Combo","title":"Test Combo","text":"  test_combo","category":"page"},{"location":"man/test_combo/#JudiLing.test_combo","page":"Test Combo","title":"JudiLing.test_combo","text":"test entire dataset in one function\n\n\n\n\n\n","category":"function"},{"location":"#JudiLing","page":"Home","title":"JudiLing","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JudiLing can be installed using the Julia package manager via GitHub web links. In Julia 1.4 REPL, we can run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.add(PackageSpec(url=\"https://github.com/MegamindHenry/JudiLing.jl.git\"))","category":"page"},{"location":"","page":"Home","title":"Home","text":"and in Julia 1.5 REPL, we can run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.add(url=\"https://github.com/MegamindHenry/JudiLing.jl.git\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or from the Julia REPL, type ] to enter the Pkg REPL mode and run","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/MegamindHenry/JudiLing.jl.git","category":"page"},{"location":"#Include-packages","page":"Home","title":"Include packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Before we start, we first need to include two packages in julia:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using JudiLing # our package\nusing CSV # read csv files into dataframes","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#Latin","page":"Home","title":"Latin","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's look at our first real dataset example. latin.csv contains lexemes and inflectional features of Latin verbs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"\"\",\"Word\",\"Lexeme\",\"Person\",\"Number\",\"Tense\",\"Voice\",\"Mood\"\n\"1\",\"vocoo\",\"vocare\",\"p1\",\"sg\",\"present\",\"active\",\"ind\"\n\"2\",\"vocaas\",\"vocare\",\"p2\",\"sg\",\"present\",\"active\",\"ind\"\n\"3\",\"vocat\",\"vocare\",\"p3\",\"sg\",\"present\",\"active\",\"ind\"\n\"4\",\"vocaamus\",\"vocare\",\"p1\",\"pl\",\"present\",\"active\",\"ind\"\n\"5\",\"vocaatis\",\"vocare\",\"p2\",\"pl\",\"present\",\"active\",\"ind\"\n\"6\",\"vocant\",\"vocare\",\"p3\",\"pl\",\"present\",\"active\",\"ind\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, we need to read the csv file:","category":"page"},{"location":"","page":"Home","title":"Home","text":"latin = CSV.DataFrame!(CSV.File(joinpath(@__DIR__, \"data\", \"latin.csv\")));","category":"page"},{"location":"","page":"Home","title":"Home","text":"and we can take a peek at the latin dataframe:","category":"page"},{"location":"","page":"Home","title":"Home","text":"display(latin)","category":"page"},{"location":"","page":"Home","title":"Home","text":"672×8 DataFrame. Omitted printing of 2 columns\n│ Row │ Column1 │ Word           │ Lexeme  │ Person │ Number │ Tense      │\n│     │ Int64   │ String         │ String  │ String │ String │ String     │\n├─────┼─────────┼────────────────┼─────────┼────────┼────────┼────────────┤\n│ 1   │ 1       │ vocoo          │ vocare  │ p1     │ sg     │ present    │\n│ 2   │ 2       │ vocaas         │ vocare  │ p2     │ sg     │ present    │\n│ 3   │ 3       │ vocat          │ vocare  │ p3     │ sg     │ present    │\n│ 4   │ 4       │ vocaamus       │ vocare  │ p1     │ pl     │ present    │\n│ 5   │ 5       │ vocaatis       │ vocare  │ p2     │ pl     │ present    │\n│ 6   │ 6       │ vocant         │ vocare  │ p3     │ pl     │ present    │\n│ 7   │ 7       │ clamoo         │ clamare │ p1     │ sg     │ present    │\n│ 8   │ 8       │ clamaas        │ clamare │ p2     │ sg     │ present    │\n⋮\n│ 664 │ 664     │ carpsisseemus  │ carpere │ p1     │ pl     │ pluperfect │\n│ 665 │ 665     │ carpsisseetis  │ carpere │ p2     │ pl     │ pluperfect │\n│ 666 │ 666     │ carpsissent    │ carpere │ p3     │ pl     │ pluperfect │\n│ 667 │ 667     │ cuccurissem    │ currere │ p1     │ sg     │ pluperfect │\n│ 668 │ 668     │ cuccurissees   │ currere │ p2     │ sg     │ pluperfect │\n│ 669 │ 669     │ cuccurisset    │ currere │ p3     │ sg     │ pluperfect │\n│ 670 │ 670     │ cuccurisseemus │ currere │ p1     │ pl     │ pluperfect │\n│ 671 │ 671     │ cuccurisseetis │ currere │ p2     │ pl     │ pluperfect │\n│ 672 │ 672     │ cuccurissent   │ currere │ p3     │ pl     │ pluperfect │","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the production model, we want to predict correct forms given their lexemes and inflectional features. For example, giving the lexeme vocare and its inflectional features p1, sg, present, active and ind, the model should produce the form vocoo. On the other hand, the comprehension model takes forms as input and tries to predict their lexemes and inflectional features.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We use letter trigrams to encode our forms. For word vocoo, for example, we use trigrams #vo, voc, oco, coo and oo#. Here, # is used as start/end token to encode the initial trigram and finial trigram of a word. The row vectors of the C matrix specify for each word which of the trigrams are realized in that word.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To make the C matrix, we use the make_cue_matrix function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"cue_obj = JudiLing.make_cue_matrix(\n  latin,\n  grams=3,\n  target_col=:Word,\n  tokenized=false,\n  keep_sep=false\n  )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, we can simulate semantic matrix S using the make_S_matrix function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"n_features = size(cue_obj.C, 2)\nS = JudiLing.make_S_matrix(\n  latin,\n  [\"Lexeme\"],\n  [\"Person\",\"Number\",\"Tense\",\"Voice\",\"Mood\"],\n  ncol=n_features)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For this simulation, first random vectors are assigned to every lexeme and inflectional feature, and next the vectors of those features are summed up to obtain the semantic vector. Similar dimensions between C and S works best. Therefore, we retrieve the number of columns from the C matrix and pass it to make_S_Matrix when constructing S.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, the next step is to calculate a mapping from S to C by solving equation C = SG. We use Cholesky decomposition to solve this equation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"G = JudiLing.make_transform_matrix(S, cue_obj.C)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, we can make our predicted C matrix Chat:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Chat = S * G","category":"page"},{"location":"","page":"Home","title":"Home","text":"and we can evaluate our predictions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@show JudiLing.eval_SC(cue_obj.C, Chat)","category":"page"},{"location":"","page":"Home","title":"Home","text":"JudiLing.eval_SC(cue_obj.C, Chat) = 1.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similar to G and Chat, we can solve S = CF:","category":"page"},{"location":"","page":"Home","title":"Home","text":"F = JudiLing.make_transform_matrix(cue_obj.C, S)","category":"page"},{"location":"","page":"Home","title":"Home","text":"and we can predict Shat matrix and evaluate it:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Shat = cue_obj.C * F\n@show JudiLing.eval_SC(S, Shat)","category":"page"},{"location":"","page":"Home","title":"Home","text":"JudiLing.eval_SC(S, Shat) = 1.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"To model speech production, the proper triphones have to be selected and put into the right order. We have two algorithms that accomplish this. Both algorithms construct paths in a triphone space that start with word-initial triphones and end with word-final triphones.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The first step is to construct an adjacency matrix that specify which triphone can follow each other. In this example, we use the adjacency matrix constructed by make_cue_matrix, but we can also make use of a independently constructed adjacency matrix if required.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A = cue_obj.A","category":"page"},{"location":"","page":"Home","title":"Home","text":"For our sequencing algorithms, we calculate the number of timesteps we need for our algorithms. For the Latin dataset, the max timestep is equal to the length of the longest word. The argument :Word specifies the column in the Latin dataset that lists the words' forms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"max_t = JudiLing.cal_max_timestep(latin, :Word)","category":"page"},{"location":"","page":"Home","title":"Home","text":"One sequence finding algorithm used discrimination learning for the position of triphones. This function returns two lists, one with the triphone paths and one with the learning supports for these paths.","category":"page"},{"location":"","page":"Home","title":"Home","text":"res = JudiLing.learn_paths(\n  latin,\n  latin,\n  cue_obj.C,\n  S,\n  F,\n  Chat,\n  A,\n  cue_obj.i2f,\n  max_t=max_t,\n  max_can=10,\n  grams=3,\n  threshold=0.1,\n  tokenized=false,\n  keep_sep=false,\n  target_col=:Word,\n  verbose=true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We evaluate the accuracy on the train data as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"acc = JudiLing.eval_acc(\n  res,\n  cue_obj.gold_ind,\n  verbose=false\n)\n\nprintln(\"Acc for train: $acc\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Acc for train: 1.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"The second sequence finding algorithm is usually faster than the first, but does not provide learnability estimates.","category":"page"},{"location":"","page":"Home","title":"Home","text":"res_build = JudiLing.build_paths(\n    latin,\n    cue_obj.C,\n    S,\n    F,\n    Chat,\n    A,\n    cue_obj.i2f,\n    cue_obj.gold_ind,\n    max_t=max_t,\n    n_neighbors=3,\n    verbose=true\n    )\n\nacc_build = JudiLing.eval_acc(\n  res_build,\n  cue_obj.gold_ind,\n  verbose=false\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Acc for build: 1.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"After having obtained the results from the sequence functions: learnpaths or buildpaths, we can save the results either into a csv or into a dataframe, they can be loaded into R with the rput command of the RCall package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"JudiLing.write2csv(\n  res_learn,\n  latin,\n  cue_obj,\n  cue_obj,\n  \"latin_learn_res.csv\",\n  grams=3,\n  tokenized=false,\n  sep_token=nothing,\n  start_end_token=\"#\",\n  output_sep_token=\"\",\n  path_sep_token=\":\",\n  target_col=:Word,\n  root_dir=@__DIR__,\n  output_dir=\"latin_out\"\n  )\n\ndf_learn = JudiLing.write2df(\n  res_learn,\n  latin,\n  cue_obj,\n  cue_obj,\n  grams=3,\n  tokenized=false,\n  sep_token=nothing,\n  start_end_token=\"#\",\n  output_sep_token=\"\",\n  path_sep_token=\":\",\n  target_col=:Word\n  )\n\nJudiLing.write2csv(\n  res_build,\n  latin,\n  cue_obj,\n  cue_obj,\n  \"latin_build_res.csv\",\n  grams=3,\n  tokenized=false,\n  sep_token=nothing,\n  start_end_token=\"#\",\n  output_sep_token=\"\",\n  path_sep_token=\":\",\n  target_col=:Word,\n  root_dir=@__DIR__,\n  output_dir=\"latin_out\"\n  )\n\ndf_build = JudiLing.write2df(\n  res_build,\n  latin,\n  cue_obj,\n  cue_obj,\n  grams=3,\n  tokenized=false,\n  sep_token=nothing,\n  start_end_token=\"#\",\n  output_sep_token=\"\",\n  path_sep_token=\":\",\n  target_col=:Word\n  )\n\ndisplay(df_learn)\ndisplay(df_build)","category":"page"},{"location":"","page":"Home","title":"Home","text":"280×9 DataFrame. Omitted printing of 7 columns\n│ Row │ utterance │ identifier │\n│     │ Int64?    │ String?    │\n├─────┼───────────┼────────────┤\n│ 1   │ 1         │ vocoo      │\n│ 2   │ 2         │ vocaas     │\n│ 3   │ 2         │ vocaas     │\n│ 4   │ 2         │ vocaas     │\n│ 5   │ 3         │ vocat      │\n│ 6   │ 4         │ vocaamus   │\n│ 7   │ 4         │ vocaamus   │\n│ 8   │ 5         │ vocaatis   │\n⋮\n│ 272 │ 196       │ vocaamur   │\n│ 273 │ 197       │ vocaaminii │\n│ 274 │ 197       │ vocaaminii │\n│ 275 │ 198       │ vocantur   │\n│ 276 │ 198       │ vocantur   │\n│ 277 │ 199       │ clamor     │\n│ 278 │ 200       │ clamaaris  │\n│ 279 │ 200       │ clamaaris  │\n│ 280 │ 200       │ clamaaris  │\n671×9 DataFrame. Omitted printing of 7 columns\n│ Row │ utterance │ identifier │\n│     │ Int64?    │ String?    │\n├─────┼───────────┼────────────┤\n│ 1   │ 1         │ vocoo      │\n│ 2   │ 1         │ vocoo      │\n│ 3   │ 1         │ vocoo      │\n│ 4   │ 2         │ vocaas     │\n│ 5   │ 2         │ vocaas     │\n│ 6   │ 2         │ vocaas     │\n│ 7   │ 2         │ vocaas     │\n│ 8   │ 3         │ vocat      │\n⋮\n│ 663 │ 198       │ vocantur   │\n│ 664 │ 198       │ vocantur   │\n│ 665 │ 199       │ clamor     │\n│ 666 │ 199       │ clamor     │\n│ 667 │ 199       │ clamor     │\n│ 668 │ 200       │ clamaaris  │\n│ 669 │ 200       │ clamaaris  │\n│ 670 │ 200       │ clamaaris  │\n│ 671 │ 200       │ clamaaris  │","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, we also have a wrapper function containing all above functionalities plus cross-validation we will discuss this in next section into one function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"JudiLing.test_combo(\n  joinpath(\"data\", \"latin.csv\"),\n  joinpath(\"latin_out\"),\n  [\"Lexeme\",\"Person\",\"Number\",\"Tense\",\"Voice\",\"Mood\"],\n  [\"Lexeme\"],\n  [\"Person\",\"Number\",\"Tense\",\"Voice\",\"Mood\"],\n  n_grams_target_col=:Word,\n  grams=3,\n  path_method=:learn_paths,\n  train_threshold=0.1,\n  val_threshold=0.01,\n  csv_dir=\"latin_out\",\n  verbose=true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once you are done, you may want to clean up the workspace:","category":"page"},{"location":"","page":"Home","title":"Home","text":"path = joinpath(@__DIR__, \"latin_out\")\nrm(path, force=true, recursive=true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can download and try out this script here.","category":"page"},{"location":"#Estonian","page":"Home","title":"Estonian","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package also provides functionality for cross-validation. In this section, we demonstrate another example with Estonian dataset. In order to perform cross-validation, we provide training dataset estonian_train.csv and hold-out dataset estonian_val.csv. Similar to Latin dataset, Estonian dataset also has target word forms, lexemes and inflectional features.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"First, we read both datasets using CSV package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"estonian_train = CSV.DataFrame!(CSV.File(\n  joinpath(@__DIR__, \"data\", \"estonian_train.csv\")))\nestonian_val = CSV.DataFrame!(CSV.File(\n  joinpath(@__DIR__, \"data\", \"estonian_val.csv\")))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, we construct both training and validation C matrices. To maintain the same trigrams' indices, we pass cue_obj_train as an argument.","category":"page"},{"location":"","page":"Home","title":"Home","text":"cue_obj_train = JudiLing.make_cue_matrix(\n  estonian_train,\n  grams=3,\n  target_col=:Word,\n  tokenized=false,\n  keep_sep=false\n  )\n\ncue_obj_val = JudiLing.make_cue_matrix(\n  estonian_val,\n  cue_obj_train,\n  grams=3,\n  target_col=:Word,\n  tokenized=false,\n  keep_sep=false\n  )","category":"page"},{"location":"","page":"Home","title":"Home","text":"After that, we construct simulate S matrices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"n_features = size(cue_obj.C, 2)\nS_train, S_val = JudiLing.make_S_matrix(\n  latin,\n  [\"Lexeme\"],\n  [\"Person\",\"Number\",\"Tense\",\"Voice\",\"Mood\"],\n  ncol=n_features)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, we construct the G matrix only use training data","category":"page"},{"location":"","page":"Home","title":"Home","text":"G_train = JudiLing.make_transform_matrix(S_train, cue_obj_train.C)","category":"page"},{"location":"","page":"Home","title":"Home","text":"and we predict and evaluate C matrices for both training and validation data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Chat_train = S_train * G_train\nChat_val = S_val * G_train\n\n@show JudiLing.eval_SC(cue_obj_train.C, Chat_train)\n@show JudiLing.eval_SC(cue_obj_val.C, Chat_val)","category":"page"},{"location":"","page":"Home","title":"Home","text":"JudiLing.eval_SC(cue_obj_train.C, Chat_train) = 0.99875\nJudiLing.eval_SC(cue_obj_val.C, Chat_val) = 0.93","category":"page"},{"location":"","page":"Home","title":"Home","text":"We follow similar processes to predict and evaluate S matrices for both training and validation data as well.","category":"page"},{"location":"","page":"Home","title":"Home","text":"F_train = JudiLing.make_transform_matrix(cue_obj_train.C, S_train)\n\nShat_train = C_train * F_train\nShat_val = C_val * F_train\n\n@show JudiLing.eval_SC(S_train, Shat_train)\n@show JudiLing.eval_SC(S_val Shat_val)","category":"page"},{"location":"","page":"Home","title":"Home","text":"JudiLing.eval_SC(S_train, Shat_train) = 0.99875\nJudiLing.eval_SC(S_val, Shat_val) = 0.99","category":"page"},{"location":"","page":"Home","title":"Home","text":"Again, we use the adjacency matrix constructed in make_cue_matrix","category":"page"},{"location":"","page":"Home","title":"Home","text":"A = cue_obj_train.A","category":"page"},{"location":"","page":"Home","title":"Home","text":"and we calculate the maximum timestep which is equal to the maximum value between training and validation data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"max_t = JudiLing.cal_max_timestep(estonian_train, estonian_val, :Word)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now we are ready for learn_paths:","category":"page"},{"location":"","page":"Home","title":"Home","text":"res_learn_train = JudiLing.learn_paths(\n  estonian_train,\n  estonian_train,\n  cue_obj_train.C,\n  S_train,\n  F_train,\n  Chat_train,\n  A,\n  cue_obj_train.i2f,\n  max_t=max_t,\n  max_can=10,\n  grams=3,\n  threshold=0.1,\n  tokenized=false,\n  keep_sep=false,\n  target_col=:Word,\n  verbose=true)\n\nres_learn_val = JudiLing.learn_paths(\n  estonian_train,\n  estonian_val,\n  cue_obj_train.C,\n  S_val,\n  F_train,\n  Chat_val,\n  A,\n  cue_obj_train.i2f,\n  max_t=max_t,\n  max_can=10,\n  grams=3,\n  threshold=0.01,\n  tokenized=false,\n  keep_sep=false,\n  target_col=:Word,\n  verbose=true)\n\nacc_learn_train = JudiLing.eval_acc(\n  res_learn_train,\n  cue_obj_train.gold_ind,\n  verbose=false\n)\n\nacc_learn_val = JudiLing.eval_acc(\n  res_learn_val,\n  cue_obj_val.gold_ind,\n  verbose=false\n)\n\nprintln(\"Acc for learn train: $acc_learn_train\")\nprintln(\"Acc for learn val: $acc_learn_val\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Acc for learn train: 1.0\nAcc for learn val: 0.31","category":"page"},{"location":"","page":"Home","title":"Home","text":"and for the build_paths:","category":"page"},{"location":"","page":"Home","title":"Home","text":"res_build_train = JudiLing.build_paths(\n  estonian_train,\n  cue_obj_train.C,\n  S_train,\n  F_train,\n  Chat_train,\n  A,\n  cue_obj_train.i2f,\n  cue_obj_train.gold_ind,\n  max_t=max_t,\n  n_neighbors=3,\n  verbose=true\n  )\n\nres_build_val = JudiLing.build_paths(\n  estonian_val,\n  cue_obj_train.C,\n  S_val,\n  F_train,\n  Chat_val,\n  A,\n  cue_obj_train.i2f,\n  cue_obj_train.gold_ind,\n  max_t=max_t,\n  n_neighbors=8,\n  verbose=true\n  )\n\nacc_build_train = JudiLing.eval_acc(\n  res_build_train,\n  cue_obj_train.gold_ind,\n  verbose=false\n)\n\nacc_build_val = JudiLing.eval_acc(\n  res_build_val,\n  cue_obj_val.gold_ind,\n  verbose=false\n)\n\nprintln(\"Acc for build train: $acc_build_train\")\nprintln(\"Acc for build val: $acc_build_val\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Acc for build train: 1.0\nAcc for build val: 0.385","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, we can save our results into csv file or dataframes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"JudiLing.write2csv(\n  res_learn_train,\n  estonian_train,\n  cue_obj_train,\n  cue_obj_train,\n  \"estonian_learn_res_train.csv\",\n  grams=3,\n  tokenized=false,\n  sep_token=nothing,\n  start_end_token=\"#\",\n  output_sep_token=\"\",\n  path_sep_token=\":\",\n  target_col=:Word,\n  root_dir=@__DIR__,\n  output_dir=\"estonian_out\"\n  )\n\nJudiLing.write2csv(\n  res_learn_val,\n  estonian_val,\n  cue_obj_train,\n  cue_obj_val,\n  \"estonian_learn_res_val.csv\",\n  grams=3,\n  tokenized=false,\n  sep_token=nothing,\n  start_end_token=\"#\",\n  output_sep_token=\"\",\n  path_sep_token=\":\",\n  target_col=:Word,\n  root_dir=@__DIR__,\n  output_dir=\"estonian_out\"\n  )\n\nJudiLing.write2csv(\n  res_build_train,\n  estonian_train,\n  cue_obj_train,\n  cue_obj_train,\n  \"estonian_build_res_train.csv\",\n  grams=3,\n  tokenized=false,\n  sep_token=nothing,\n  start_end_token=\"#\",\n  output_sep_token=\"\",\n  path_sep_token=\":\",\n  target_col=:Word,\n  root_dir=@__DIR__,\n  output_dir=\"estonian_out\"\n  )\n\nJudiLing.write2csv(\n  res_build_val,\n  estonian_val,\n  cue_obj_train,\n  cue_obj_val,\n  \"estonian_build_res_val.csv\",\n  grams=3,\n  tokenized=false,\n  sep_token=nothing,\n  start_end_token=\"#\",\n  output_sep_token=\"\",\n  path_sep_token=\":\",\n  target_col=:Word,\n  root_dir=@__DIR__,\n  output_dir=\"estonian_out\"\n  )\n\ndf_learn_train = JudiLing.write2df(\n  res_learn_train,\n  estonian_train,\n  cue_obj_train,\n  cue_obj_train,\n  grams=3,\n  tokenized=false,\n  sep_token=nothing,\n  start_end_token=\"#\",\n  output_sep_token=\"\",\n  path_sep_token=\":\",\n  target_col=:Word\n  )\n\ndf_learn_val = JudiLing.write2df(\n  res_learn_val,\n  estonian_val,\n  cue_obj_train,\n  cue_obj_val,\n  grams=3,\n  tokenized=false,\n  sep_token=nothing,\n  start_end_token=\"#\",\n  output_sep_token=\"\",\n  path_sep_token=\":\",\n  target_col=:Word\n  )\n\ndf_build_train = JudiLing.write2df(\n  res_build_train,\n  estonian_train,\n  cue_obj_train,\n  cue_obj_train,\n  grams=3,\n  tokenized=false,\n  sep_token=nothing,\n  start_end_token=\"#\",\n  output_sep_token=\"\",\n  path_sep_token=\":\",\n  target_col=:Word\n  )\n\ndf_build_val = JudiLing.write2df(\n  res_build_val,\n  estonian_val,\n  cue_obj_train,\n  cue_obj_val,\n  grams=3,\n  tokenized=false,\n  sep_token=nothing,\n  start_end_token=\"#\",\n  output_sep_token=\"\",\n  path_sep_token=\":\",\n  target_col=:Word\n  )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once you are done, you may want to clean up the workspace:","category":"page"},{"location":"","page":"Home","title":"Home","text":"path = joinpath(@__DIR__, \"estonian_out\")\nrm(path, force=true, recursive=true)","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find our work helpful, please cite these following papers:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Baayen, R. H., Chuang, Y. Y., Shafaei-Bajestan, E., and Blevins, J. P. (2019). The discriminative lexicon: A unified computational model for the lexicon and lexical processing in comprehension and production grounded not in (de)composition but in linear discriminative learning. Complexity, 2019, 1-39.\nBaayen, R. H., Chuang, Y. Y., and Blevins, J. P. (2018). Inflectional morphology with linear mappings. The Mental Lexicon, 13 (2), 232-270.\nChuang, Y.-Y., Lõo, K., Blevins, J. P., and Baayen, R. H. (in press). Estonian case inflection made simple. A case study in Word and Paradigm morphology with Linear Discriminative Learning. In Körtvélyessy, L., and Štekauer, P. (Eds.) Complex Words: Advances in Morphology, 1-19.\nChuang, Y-Y., Bell, M. J., Banke, I., and Baayen, R. H. (accepted). Bilingual and multilingual mental lexicon: a modeling study with Linear Discriminative Learning. Language Learning, 1-55.","category":"page"},{"location":"man/make_cue_matrix/","page":"Make Cue Matrix","title":"Make Cue Matrix","text":"CurrentModule = JudiLing","category":"page"},{"location":"man/make_cue_matrix/#Make-Cue-Matrix","page":"Make Cue Matrix","title":"Make Cue Matrix","text":"","category":"section"},{"location":"man/make_cue_matrix/","page":"Make Cue Matrix","title":"Make Cue Matrix","text":"  Cue_Matrix_Struct\r\n  make_cue_matrix\r\n  make_ngrams\r\n  make_cue_matrix(::DataFrame)\r\n  make_cue_matrix(::DataFrame,::Cue_Matrix_Struct)\r\n  make_ngrams(::Array,::Int64,::Bool,::Union{Nothing, String, Char},::Union{String, Char})","category":"page"},{"location":"man/make_cue_matrix/#JudiLing.Cue_Matrix_Struct","page":"Make Cue Matrix","title":"JudiLing.Cue_Matrix_Struct","text":"a structure that store info after makecuematrix C is the cue matrix f2i is the dictionary return indices giving features i2f is in another hand return features when giving indices gold_ind stores gold paths within a list of indices A is the adjacency matrix\n\n\n\n\n\n","category":"type"},{"location":"man/make_cue_matrix/#JudiLing.make_cue_matrix","page":"Make Cue Matrix","title":"JudiLing.make_cue_matrix","text":"Construct cue matrix.\n\n\n\n\n\n","category":"function"},{"location":"man/make_cue_matrix/#JudiLing.make_ngrams","page":"Make Cue Matrix","title":"JudiLing.make_ngrams","text":"Given tokens make n-grams.\n\n\n\n\n\n","category":"function"},{"location":"man/make_cue_matrix/#JudiLing.make_cue_matrix-Tuple{DataFrames.DataFrame}","page":"Make Cue Matrix","title":"JudiLing.make_cue_matrix","text":"makecuematrix(::DataFrame) -> ::CueMatrixStruct\n\nMakes the cue matrix and corresponding indices given dataset as csv file.\n\n...\n\nArguments\n\ngrams::Int64=3: the number of grams for cues \ntarget_col::Union{String, Symbol}=:Words: the column name for target\ntokenized::Bool=false:if true, the dataset target is assumed tokenized\nsep_token::Union{Nothing, String, Char}=nothing: separate token\nkeep_sep::Bool=false: if true, keep separators in cues\nstart_end_token::Union{String, Char}=\"#\": start and end token\nverbose::Bool=false: if true, more information prints out\n\nExamples\n\n# make cue matrix with not tokenized dataset\ncue_obj_train = JudiLing.make_cue_matrix(\n  latin_train,\n  grams=3,\n  target_col=:Word,\n  tokenized=false,\n  sep_token=\"-\",\n  start_end_token=\"#\",\n  keep_sep=false,\n  verbose=false\n  )\n\n# make cue matrix with tokenized dataset\ncue_obj_train = JudiLing.make_cue_matrix(\n  french_train,\n  grams=3,\n  target_col=:Syllables,\n  tokenized=true,\n  sep_token=\"-\",\n  start_end_token=\"#\",\n  keep_sep=true,\n  verbose=false\n  )\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/make_cue_matrix/#JudiLing.make_cue_matrix-Tuple{DataFrames.DataFrame,JudiLing.Cue_Matrix_Struct}","page":"Make Cue Matrix","title":"JudiLing.make_cue_matrix","text":"makecuematrix(::DataFrame,::CueMatrixStruct) -> ::CueMatrixStruct\n\nMake the cue matrix and corresponding indices giving dataset as csv file and train dataset cue obj. This is often used to construct valcueobj, in order to maintain the same indices.\n\n...\n\nArguments\n\ngrams::Int64=3: which n-grams for cues \ntarget_col::Union{String, Symbol}=:Words: the column name for target\ntokenized::Bool=false:if true, the dataset target is assumed tokenized\nsep_token::Union{Nothing, String, Char}=nothing: separate token\nkeep_sep::Bool=false: if true, keep separators in cues\nstart_end_token::Union{String, Char}=\"#\": start and end token\nverbose::Bool=false: if true, more information prints out\n\nExamples\n\n# make cue matrix with not tokenized dataset\ncue_obj_val = JudiLing.make_cue_matrix(\n  latin_val,\n  cue_obj_train,\n  grams=3,\n  target_col=:Word,\n  tokenized=false,\n  sep_token=\"-\",\n  keep_sep=false,\n  start_end_token=\"#\",\n  verbose=false\n  )\n\n# make cue matrix with tokenized dataset\ncue_obj_val = JudiLing.make_cue_matrix(\n  french_val,\n  cue_obj_train,\n  grams=3,\n  target_col=:Syllables,\n  tokenized=true,\n  sep_token=\"-\",\n  keep_sep=true,\n  start_end_token=\"#\",\n  verbose=false\n  )\n\n...\n\n\n\n\n\n","category":"method"},{"location":"man/make_cue_matrix/#JudiLing.make_ngrams-Tuple{Array,Int64,Bool,Union{Nothing, Char, String},Union{Char, String}}","page":"Make Cue Matrix","title":"JudiLing.make_ngrams","text":"make_ngrams(::Array,::Int64,::Bool, ::Union{Nothing, String, Char},::Union{String, Char} -> ::Array\n\ngiven a list of tokens, return all ngrams in a list\n\n\n\n\n\n","category":"method"}]
}
